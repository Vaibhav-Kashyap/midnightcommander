diff --git a/lib/global.h b/lib/global.h
index ecc4d89..106a4e2 100644
--- a/lib/global.h
+++ b/lib/global.h
@@ -27,10 +27,16 @@
 /*** typedefs(not structures) and defined constants **********************************************/
 
 /* The O_BINARY definition was taken from gettext */
+#if defined(__WATCOMC__) //WIN32/APY
+#include <fcntl.h>
+#include <inttypes.h>
+
+#elif defined(_MSC_VER)
 #if !defined O_BINARY && defined _O_BINARY
   /* For MSC-compatible compilers.  */
 #define O_BINARY _O_BINARY
 #endif
+#endif
 #ifdef __BEOS__
   /* BeOS 5 has O_BINARY, but is has no effect.  */
 #undef O_BINARY
@@ -45,7 +51,11 @@
 #ifdef O_NDELAY                 /* SYSV */
 #define O_NONBLOCK O_NDELAY
 #else /* BSD */
+#ifdef WIN32 //WIN32/APY
+#define O_NONBLOCK 0
+#else
 #define O_NONBLOCK FNDELAY
+#endif
 #endif /* !O_NDELAY */
 #endif /* !O_NONBLOCK */
 
@@ -66,9 +76,11 @@
 #endif
 
 /* Solaris9 doesn't have PRIXMAX */
+#ifndef __WATCOMC__ //WIN32, fix
 #ifndef PRIXMAX
 #define PRIXMAX PRIxMAX
 #endif
+#endif
 
 #ifdef ENABLE_NLS
 #include <libintl.h>
@@ -128,6 +140,9 @@
 /* OS specific defines */
 #define PATH_SEP '/'
 #define PATH_SEP_STR "/"
+#if defined(WIN32) //APY,path
+#define PATH_SEP_STR2 "\\"
+#endif
 #define PATH_ENV_SEP ':'
 #define TMPDIR_DEFAULT "/tmp"
 #define SCRIPT_SUFFIX ""
@@ -155,7 +170,13 @@
 
 #define MC_ERROR g_quark_from_static_string (PACKAGE)
 
+#ifdef WIN32 //WIN32/APY, conflict with w32 headers
+#define MC_DEFAULT_CHARSET "ASCII"
+#undef  DEFAULT_CHARSET
+#define DEFAULT_CHARSET MC_DEFAULT_CHARSET
+#else
 #define DEFAULT_CHARSET "ASCII"
+#endif
 
 /*** enums ***************************************************************************************/
 
diff --git a/lib/keybind.c b/lib/keybind.c
index ce426b4..ca02372 100644
--- a/lib/keybind.c
+++ b/lib/keybind.c
@@ -181,7 +181,7 @@ static name_keymap_t command_names[] = {
     {"PanelListingChange", CK_PanelListingChange},
     {"PanelListing", CK_PanelListing},
 #ifdef LISTMODE_EDITOR
-    {"ListMode", CK_ListMode}.
+    {"ListMode", CK_ListMode}, //APY, optional
 #endif
     {"OptionsPanel", CK_OptionsPanel},
     {"CdQuick", CK_CdQuick},
@@ -357,6 +357,13 @@ static name_keymap_t command_names[] = {
     {"MergeOther", CK_MergeOther},
 #endif /* USE_DIFF_VIEW */
 
+#if defined(WIN32) //APY, drive
+    /* Change drive */
+    {"DriveChangeA", CK_DriveChangeA},
+    {"DriveChangeB", CK_DriveChangeB},
+    {"DriveChange", CK_DriveChange},
+#endif
+
     {NULL, CK_IgnoreKey}
 };
 
diff --git a/lib/keybind.h b/lib/keybind.h
index d8ed810..dbd1980 100644
--- a/lib/keybind.h
+++ b/lib/keybind.h
@@ -330,7 +330,12 @@ enum
     CK_HunkPrev,
     CK_EditOther,
     CK_Merge,
-    CK_MergeOther
+    CK_MergeOther,
+
+    /* Change drive support (WIN32/APY) */
+    CK_DriveChange = 800,
+    CK_DriveChangeA,
+    CK_DriveChangeB
 };
 
 /*** structures declarations (and typedefs of structures)*****************************************/
diff --git a/lib/search.h b/lib/search.h
index faa3207..4f6aaf4 100644
--- a/lib/search.h
+++ b/lib/search.h
@@ -13,11 +13,6 @@
 
 /*** typedefs(not structures) and defined constants **********************************************/
 
-typedef enum mc_search_cbret_t mc_search_cbret_t;
-
-typedef mc_search_cbret_t (*mc_search_fn) (const void *user_data, gsize char_offset,
-                                           int *current_char);
-typedef mc_search_cbret_t (*mc_update_fn) (const void *user_data, gsize char_offset);
 
 #define MC_SEARCH__NUM_REPLACE_ARGS 64
 
@@ -47,13 +42,17 @@ typedef enum
     MC_SEARCH_T_GLOB
 } mc_search_type_t;
 
-enum mc_search_cbret_t
+typedef enum
 {
     MC_SEARCH_CB_OK = 0,
     MC_SEARCH_CB_INVALID = -1,
     MC_SEARCH_CB_ABORT = -2,
     MC_SEARCH_CB_SKIP = -3
-};
+} mc_search_cbret_t;
+
+typedef mc_search_cbret_t (*mc_search_fn) (const void *user_data, gsize char_offset,
+                                           int *current_char);
+typedef mc_search_cbret_t (*mc_update_fn) (const void *user_data, gsize char_offset);
 
 /*** structures declarations (and typedefs of structures)*****************************************/
 
diff --git a/lib/tty/x11conn.c b/lib/tty/x11conn.c
index 62b01ea..cf0de4b 100644
--- a/lib/tty/x11conn.c
+++ b/lib/tty/x11conn.c
@@ -31,6 +31,8 @@
 
 #include <config.h>
 
+#if defined(WIN32) //WIN32
+#else
 #include <setjmp.h>
 #include <X11/Xlib.h>
 #ifdef HAVE_GMODULE
@@ -260,3 +262,6 @@ mc_XQueryPointer (Display * display, Window win, Window * root_return,
 }
 
 /* --------------------------------------------------------------------------------------------- */
+
+#endif  //WIN32
+
diff --git a/lib/vfs/interface.c b/lib/vfs/interface.c
index ee04964..4d1604c 100644
--- a/lib/vfs/interface.c
+++ b/lib/vfs/interface.c
@@ -76,11 +76,34 @@ struct dirent *mc_readdir_result = NULL;
 /*** file scope functions ************************************************************************/
 /* --------------------------------------------------------------------------------------------- */
 
+#if defined(WIN32)
+#undef  mkdir
+#undef  rmdir
+#undef  read
+#undef  link
+#undef  unlink
+#undef  readlink
+#undef  symlink
+#undef  utime
+#undef  write
+#define MKDIR           w32_mkdir
+#define LINK            w32_link
+#define UNLINK          w32_unlink
+#define WRITE           w32_write
+#define READ            w32_read
+#else
+#define MKDIR           mkdir
+#define LINK            link
+#define UNLINK          unlink
+#define WRITE           write
+#define READ            read
+#endif
+
 static vfs_path_t *
 mc_def_getlocalcopy (const vfs_path_t * filename_vpath)
 {
     vfs_path_t *tmp_vpath = NULL;
-    int fdin, fdout = -1;
+    int fdin = -1, fdout = -1;
     ssize_t i;
     char buffer[BUF_1K * 8];
     struct stat mystat;
@@ -95,7 +118,7 @@ mc_def_getlocalcopy (const vfs_path_t * filename_vpath)
 
     while ((i = mc_read (fdin, buffer, sizeof (buffer))) > 0)
     {
-        if (write (fdout, buffer, i) != i)
+        if (WRITE (fdout, buffer, i) != i)
             goto fail;
     }
     if (i == -1)
@@ -149,7 +172,7 @@ mc_def_ungetlocalcopy (const vfs_path_t * filename_vpath,
         fdout = mc_open (filename_vpath, O_WRONLY | O_TRUNC);
         if (fdout == -1)
             goto failed;
-        while ((i = read (fdin, buffer, sizeof (buffer))) > 0)
+        while ((i = READ (fdin, buffer, sizeof (buffer))) > 0)
             if (mc_write (fdout, buffer, (size_t) i) != i)
                 goto failed;
         if (i == -1)
@@ -167,7 +190,7 @@ mc_def_ungetlocalcopy (const vfs_path_t * filename_vpath,
             goto failed;
         }
     }
-    unlink (local);
+    UNLINK (local);
     return 0;
 
   failed:
@@ -176,7 +199,7 @@ mc_def_ungetlocalcopy (const vfs_path_t * filename_vpath,
         mc_close (fdout);
     if (fdin != -1)
         close (fdin);
-    unlink (local);
+    UNLINK (local);
     return -1;
 }
 
@@ -825,11 +848,18 @@ mc_tmpdir (void)
         st.st_uid == getuid () && (st.st_mode & 0777) == 0700)
         return tmpdir;
 
+#if defined(WIN32)
+    if (NULL == (sys_tmp = mc_TMPDIR())) {
+        sys_tmp = TMPDIR_DEFAULT;
+    }
+#else
+#error
     sys_tmp = getenv ("TMPDIR");
     if (!sys_tmp || sys_tmp[0] != '/')
     {
         sys_tmp = TMPDIR_DEFAULT;
     }
+#endif
 
     pwd = getpwuid (getuid ());
 
@@ -841,6 +871,18 @@ mc_tmpdir (void)
     canonicalize_pathname (buffer);
 
     /* Try to create directory */
+#if defined(WIN32)
+    if (MKDIR (buffer, S_IRWXU) != 0)
+    {
+        if (errno != EEXIST || stat (buffer, &st) != 0)
+        {
+            fprintf (stderr,
+                     _("Cannot create temporary directory %s: %s\n"),
+                     buffer, unix_error_string (errno));
+            error = "";
+        }
+    }
+#else
     if (mkdir (buffer, S_IRWXU) != 0)
     {
         if (errno == EEXIST && lstat (buffer, &st) == 0)
@@ -861,6 +903,7 @@ mc_tmpdir (void)
             error = "";
         }
     }
+#endif
 
     if (error != NULL)
     {
@@ -883,7 +926,7 @@ mc_tmpdir (void)
             if (test_fd != -1)
             {
                 close (test_fd);
-                unlink (vfs_path_as_str (test_vpath));
+                UNLINK (vfs_path_as_str (test_vpath));
                 fallback_ok = TRUE;
             }
         }
diff --git a/lib/vfs/parse_ls_vga.c b/lib/vfs/parse_ls_vga.c
index c102b7d..c93d72a 100644
--- a/lib/vfs/parse_ls_vga.c
+++ b/lib/vfs/parse_ls_vga.c
@@ -682,12 +682,15 @@ vfs_parse_ls_lga (const char *p, struct stat * s, char **filename, char **linkna
     char *t = NULL;
     const char *line = p;
     size_t skipped;
+    mode_t mode;
 
     if (strncmp (p, "total", 5) == 0)
         return FALSE;
 
-    if (!vfs_parse_filetype (p, &skipped, &s->st_mode))
+    mode = s->st_mode;          /* WIN32, st_mode type may not be mode_t */
+    if (!vfs_parse_filetype (p, &skipped, &mode))
         goto error;
+    s->st_mode = mode;
     p += skipped;
 
     if (*p == ' ')              /* Notwell 4 */
diff --git a/lib/vfs/path.c b/lib/vfs/path.c
index 690cf66..d16e4f2 100644
--- a/lib/vfs/path.c
+++ b/lib/vfs/path.c
@@ -33,6 +33,9 @@
 
 
 #include <config.h>
+#if defined(WIN32) //APY, drive
+#include <ctype.h>
+#endif
 
 #include "lib/global.h"
 #include "lib/strutil.h"
@@ -132,6 +135,20 @@ _vfs_split_with_semi_skip_count (char *path, const char **inpath, const char **o
  * @return newly allocated string
  */
 
+#if defined(WIN32) //APY, drive
+static __inline int
+drive_or_unc(const char *path)
+{
+    if (*path) {                                /* //<server> or X:... */
+        if ((PATH_SEP == path[0] && PATH_SEP == path[1]) ||
+                (isalpha((unsigned char)path[0]) && ':' == path[1])) {
+            return TRUE;
+        }
+    }
+    return FALSE;
+}
+#endif
+
 static char *
 vfs_canon (const char *path)
 {
@@ -139,7 +156,11 @@ vfs_canon (const char *path)
         vfs_die ("Cannot canonicalize NULL");
 
     /* Relative to current directory */
+#if defined(WIN32) //APY, drive
+    if (!drive_or_unc(path))
+#else
     if (*path != PATH_SEP)
+#endif
     {
         char *result, *local;
 
@@ -448,6 +469,12 @@ vfs_path_from_str_uri_parser (char *path, vfs_path_flag_t flags)
         char *real_vfs_prefix_start = url_delimiter;
         struct vfs_s_subclass *sub = NULL;
 
+#if defined(WIN32) //APY, drive
+        if (url_delimiter == (path + 1) && isalpha((unsigned char)*path)) {
+            break;
+        }
+#endif
+
         while (real_vfs_prefix_start > path && *(real_vfs_prefix_start) != PATH_SEP)
             real_vfs_prefix_start--;
         vfs_prefix_start = real_vfs_prefix_start;
@@ -613,6 +640,30 @@ vfs_path_strip_home (const char *dir)
     } \
 }
 
+//WIN32 APY, drive
+static void
+append_from_path(const char *appendfrom, const int is_relative,
+        const vfs_path_flag_t flags, GString *buffer, const int element_index, const vfs_path_element_t *element)
+{
+    if ((flags & VPF_STRIP_HOME) && element_index == 0 && (element->class->flags & VFSF_LOCAL) != 0)
+    {
+        char *stripped_home_str;
+        stripped_home_str = vfs_path_strip_home (appendfrom);
+        g_string_append (buffer, stripped_home_str);
+        g_free (stripped_home_str);
+    }
+    else
+    {
+        if ((!is_relative) && (*appendfrom != PATH_SEP) && (*appendfrom != '\0')
+            && (buffer->len == 0 || buffer->str[buffer->len - 1] != PATH_SEP))
+
+#if defined(WIN32) //APY, drive
+            if (element_index > 0 || ':' != appendfrom[1] || 0 == isalpha((unsigned char)appendfrom[0]))
+#endif
+                g_string_append_c (buffer, PATH_SEP);
+        g_string_append (buffer, appendfrom);
+    }
+}
 /**
  * Convert first elements_count elements from vfs_path_t to string representation with flags.
  *
@@ -680,13 +731,15 @@ vfs_path_to_str_flags (const vfs_path_t * vpath, int elements_count, vfs_path_fl
                 g_string_append (buffer, element->encoding);
             }
             str_vfs_convert_from (element->dir.converter, element->path, recode_buffer);
-            vfs_append_from_path (recode_buffer->str, is_relative);
+            append_from_path (recode_buffer->str, is_relative, flags, buffer, element_index, element);
+//WIN32     vfs_append_from_path (recode_buffer->str, is_relative);
             g_string_set_size (recode_buffer, 0);
         }
         else
 #endif
         {
-            vfs_append_from_path (element->path, is_relative);
+            append_from_path (element->path, is_relative, flags, buffer, element_index, element);
+//WIN32     vfs_append_from_path (element->path, is_relative);
         }
     }
     g_string_free (recode_buffer, TRUE);
diff --git a/lib/vfs/xdirentry.h b/lib/vfs/xdirentry.h
index c1b2c9b..d47cdd3 100644
--- a/lib/vfs/xdirentry.h
+++ b/lib/vfs/xdirentry.h
@@ -10,6 +10,9 @@
 
 #include <stdio.h>
 #include <sys/types.h>
+//WIN,fix
+#include <sys/time.h>
+#include <time.h>
 
 #include "lib/global.h"         /* GList */
 #include "lib/vfs/path.h"       /* vfs_path_t */
diff --git a/lib/widget/quick.h b/lib/widget/quick.h
index 73482d6..e5d457a 100644
--- a/lib/widget/quick.h
+++ b/lib/widget/quick.h
@@ -338,6 +338,253 @@ typedef struct
     mouse_h mouse;
 } quick_dialog_t;
 
+/*** WIN32 ****/
+
+#if defined(WIN32)
+inline quick_widget_t *
+XQUICK_CHECKBOX(quick_widget_t *qc,
+    const char *txt, int *st, unsigned long *id_)
+{
+    quick_widget_t tqc = {0};
+    tqc.widget_type = quick_checkbox;
+    tqc.options = 0;
+    tqc.pos_flags = WPOS_KEEP_DEFAULT;
+    tqc.id = id_;
+    tqc.u.checkbox.text = txt;
+    tqc.u.checkbox.state = st;
+    *qc = tqc;
+    return ++qc;
+}
+
+inline quick_widget_t *
+XQUICK_BUTTON(quick_widget_t *qc,
+    const char *txt, int act, bcback_fn cb, unsigned long *id_)
+{
+    quick_widget_t tqc = {0};
+    tqc.widget_type = quick_button;
+    tqc.options = 0;
+    tqc.pos_flags = WPOS_KEEP_DEFAULT;
+    tqc.id = id_;
+    tqc.u.button.text = txt;
+    tqc.u.button.action = act;
+    tqc.u.button.callback = cb;
+    *qc = tqc;
+    return ++qc;
+}
+
+inline quick_widget_t *
+XQUICK_INPUT(quick_widget_t *qc,
+    const char *txt, const char *hname, char **res, unsigned long *id_,
+        int is_passwd_, int strip_passwd_, int completion_flags_)
+{
+    quick_widget_t tqc = {0};
+
+    tqc.widget_type = quick_input;
+    tqc.options = 0;
+    tqc.pos_flags = WPOS_KEEP_DEFAULT;
+    tqc.id = id_;
+    tqc.u.input.label_text = NULL;
+    tqc.u.input.label_location = input_label_none;
+    tqc.u.input.label = NULL;
+    tqc.u.input.text = txt;
+    tqc.u.input.completion_flags = completion_flags_;
+    tqc.u.input.is_passwd = is_passwd_;
+    tqc.u.input.strip_passwd = strip_passwd_;
+    tqc.u.input.histname = hname;
+    tqc.u.input.result = res;
+    *qc = tqc;
+    return ++qc;
+}
+
+inline quick_widget_t *
+XQUICK_LABELED_INPUT(quick_widget_t *qc,
+    const char *label_, quick_input_label_location_t label_loc,
+    const char *txt, const char *hname, char **res, unsigned long *id_,
+    int is_passwd_, int strip_passwd_, int completion_flags_)
+{
+    quick_widget_t tqc = {0};
+    tqc.widget_type = quick_input;
+    tqc.options = 0;
+    tqc.pos_flags = WPOS_KEEP_DEFAULT;
+    tqc.id = id_;
+    tqc.u.input.label_text = label_;
+    tqc.u.input.label_location = label_loc;
+    tqc.u.input.label = NULL;
+    tqc.u.input.text = txt;
+    tqc.u.input.completion_flags = completion_flags_;
+    tqc.u.input.is_passwd = is_passwd_;
+    tqc.u.input.strip_passwd = strip_passwd_;
+    tqc.u.input.histname = hname;
+    tqc.u.input.result = res;
+    *qc = tqc;
+    return ++qc;
+}
+
+inline quick_widget_t *
+XQUICK_LABEL(quick_widget_t *qc,
+    const char *txt, unsigned long *id_)
+{
+    quick_widget_t tqc = {0};
+    tqc.widget_type = quick_label;
+    tqc.options = 0;
+    tqc.pos_flags = WPOS_KEEP_DEFAULT;
+    tqc.id = id_;
+    tqc.u.label.text = txt;
+    tqc.u.label.input = NULL;
+    *qc = tqc;
+    return ++qc;
+}
+
+inline quick_widget_t *
+XQUICK_RADIO(quick_widget_t *qc,
+    int cnt, const char **items_, int *val, unsigned long *id_)
+{
+    quick_widget_t tqc = {0};
+
+    tqc.widget_type = quick_radio;
+    tqc.options = 0;
+    tqc.pos_flags = WPOS_KEEP_DEFAULT;
+    tqc.id = id_;
+    tqc.u.radio.count = cnt;
+    tqc.u.radio.items = items_;
+    tqc.u.radio.value = val;
+    *qc = tqc;
+    return ++qc;
+}
+
+inline quick_widget_t *
+XQUICK_START_GROUPBOX(quick_widget_t *qc, const char *t)
+{
+    quick_widget_t tqc = {0};
+    tqc.widget_type = quick_start_groupbox;
+    tqc.options = 0;
+    tqc.pos_flags = WPOS_KEEP_DEFAULT;
+    tqc.id = NULL;
+    tqc.u.groupbox.title = t;
+    *qc = tqc;
+    return ++qc;
+}
+
+inline quick_widget_t *
+XQUICK_STOP_GROUPBOX(quick_widget_t *qc)
+{
+    quick_widget_t tqc = {0};
+    tqc.widget_type = quick_stop_groupbox;
+    tqc.options = 0;
+    tqc.pos_flags = WPOS_KEEP_DEFAULT;
+    tqc.id = NULL;
+    tqc.u.input.text = NULL;
+    tqc.u.input.completion_flags = 0;
+    tqc.u.input.is_passwd = 0;
+    tqc.u.input.strip_passwd = 0;
+    tqc.u.input.histname = NULL;
+    tqc.u.input.result = NULL;
+    *qc = tqc;
+    return ++qc;
+}
+
+inline quick_widget_t *
+XQUICK_SEPARATOR(quick_widget_t *qc, gboolean line_)
+{
+    quick_widget_t tqc = {0};
+    tqc.widget_type = quick_separator;
+    tqc.options = 0;
+    tqc.pos_flags = WPOS_KEEP_DEFAULT;
+    tqc.id = NULL;
+    tqc.u.separator.space = TRUE;
+    tqc.u.separator.line = line_;
+    *qc = tqc;
+    return ++qc;
+}
+
+inline quick_widget_t *
+XQUICK_START_COLUMNS(quick_widget_t *qc)
+{
+    quick_widget_t tqc = {0};
+    tqc.widget_type = quick_start_columns;
+    tqc.options = 0;
+    tqc.pos_flags = WPOS_KEEP_DEFAULT;
+    tqc.id = NULL;
+    tqc.u.input.text = NULL;
+    tqc.u.input.completion_flags = 0;
+    tqc.u.input.is_passwd = 0;
+    tqc.u.input.strip_passwd = 0;
+    tqc.u.input.histname = NULL;
+    tqc.u.input.result = NULL;
+    *qc = tqc;
+    return ++qc;
+}
+
+inline quick_widget_t *
+XQUICK_NEXT_COLUMN(quick_widget_t *qc)
+{
+    quick_widget_t tqc = {0};
+    tqc.widget_type = quick_next_column;
+    tqc.options = 0;
+    tqc.pos_flags = WPOS_KEEP_DEFAULT;
+    tqc.id = NULL;
+    tqc.u.input.text = NULL;
+    tqc.u.input.completion_flags = 0;
+    tqc.u.input.is_passwd = 0;
+    tqc.u.input.strip_passwd = 0;
+    tqc.u.input.histname = NULL;
+    tqc.u.input.result = NULL;
+    *qc = tqc;
+    return ++qc;
+}
+
+inline quick_widget_t *
+XQUICK_STOP_COLUMNS(quick_widget_t *qc)
+{
+    quick_widget_t tqc = {0};
+    tqc.widget_type = quick_stop_columns;
+    tqc.options = 0;
+    tqc.pos_flags = WPOS_KEEP_DEFAULT;
+    tqc.id = NULL;
+    tqc.u.input.text = NULL;
+    tqc.u.input.completion_flags = 0;
+    tqc.u.input.is_passwd = 0;
+    tqc.u.input.strip_passwd = 0;
+    tqc.u.input.histname = NULL;
+    tqc.u.input.result = NULL;
+    *qc = tqc;
+    return ++qc;
+}
+
+inline quick_widget_t *
+XQUICK_START_BUTTONS(quick_widget_t *qc, gboolean space_, gboolean line_)
+{
+    quick_widget_t tqc = {0};
+    tqc.widget_type = quick_buttons;
+    tqc.options = 0;
+    tqc.pos_flags = WPOS_KEEP_DEFAULT;
+    tqc.id = NULL;
+    tqc.u.separator.space = space_;
+    tqc.u.separator.line = line_;
+    *qc = tqc;
+    return ++qc;
+}
+
+inline quick_widget_t *
+XQUICK_BUTTONS_OK_CANCEL(quick_widget_t *qc)
+{
+    qc = XQUICK_START_BUTTONS (qc, TRUE, TRUE);
+    qc = XQUICK_BUTTON (qc, N_("&OK"), B_ENTER, NULL, NULL);
+    qc = XQUICK_BUTTON (qc, N_("&Cancel"), B_CANCEL, NULL, NULL);
+    return qc;
+}
+
+inline quick_widget_t *
+XQUICK_END(quick_widget_t *qc)
+{
+    quick_widget_t tqc = {0};
+    tqc.widget_type = quick_end;
+    tqc.pos_flags = WPOS_KEEP_DEFAULT;
+    *qc = tqc;
+    return ++qc;
+}
+#endif  //WIN32
+
 /*** global variables defined in .c file *********************************************************/
 
 /*** declarations of public functions ************************************************************/
diff --git a/lib/widget/wtools.c b/lib/widget/wtools.c
index 058db93..5db206a 100644
--- a/lib/widget/wtools.c
+++ b/lib/widget/wtools.c
@@ -42,6 +42,7 @@
 #include "lib/strutil.h"
 #include "lib/util.h"           /* tilde_expand() */
 #include "lib/widget.h"
+#include "lib/widget/quick.h"   // missing
 #include "lib/event.h"          /* mc_event_raise() */
 
 /*** global variables ****************************************************************************/
@@ -210,6 +211,10 @@ fg_input_dialog_help (const char *header, const char *text, const char *help,
     }
 
     {
+#if defined(WIN32)  //WIN32,quick
+        quick_widget_t quick_widgets[5],
+            *qc = quick_widgets;
+#else
         quick_widget_t quick_widgets[] = {
             /* *INDENT-OFF* */
             QUICK_LABELED_INPUT (p_text, input_label_above, def_text, histname, &my_str,
@@ -218,12 +223,22 @@ fg_input_dialog_help (const char *header, const char *text, const char *help,
             QUICK_END
             /* *INDENT-ON* */
         };
+#endif
 
         quick_dialog_t qdlg = {
             -1, -1, COLS / 2, header,
             help, quick_widgets, NULL, NULL
         };
 
+#if defined(WIN32)  //WIN32, quick
+        qc = XQUICK_LABELED_INPUT (qc,
+                            p_text, input_label_above, def_text, histname, &my_str,
+                            NULL, is_passwd, strip_password, completion_flags);
+        qc = XQUICK_BUTTONS_OK_CANCEL (qc);
+        qc = XQUICK_END (qc);
+        assert(qc == (quick_widgets + (sizeof(quick_widgets)/sizeof(quick_widgets[0]))));
+#endif
+
         ret = quick_dialog (&qdlg);
     }
 
diff --git a/misc/mc.default.keymap b/misc/mc.default.keymap
index a82756f..bb39e74 100644
--- a/misc/mc.default.keymap
+++ b/misc/mc.default.keymap
@@ -53,6 +53,9 @@ ScreenList = alt-prime
 # ConnectSmb =
 # Undelete =
 ExtendedKeyMap = ctrl-x
+DriveChange = alt-d
+DriveChangeA = alt-f1
+DriveChangeB = alt-f2
 
 [main:xmap]
 ChangeMode = c
@@ -124,6 +127,8 @@ Bottom = alt-gt; end; c1
 # SortByMTime =
 # ScrollLeft =
 # ScrollRight =
+DriveChangeA = alt-f1
+DriveChangeB = alt-f2
 
 [dialog]
 Ok = enter
diff --git a/misc/mc.emacs.keymap b/misc/mc.emacs.keymap
index 4c43c5c..6cffd15 100644
--- a/misc/mc.emacs.keymap
+++ b/misc/mc.emacs.keymap
@@ -53,6 +53,7 @@ ScreenList = alt-prime
 # ConnectSmb =
 # Undelete =
 ExtendedKeyMap = ctrl-x
+DriveChange = alt-d
 
 [main:xmap]
 ChangeMode = c
diff --git a/misc/syntax/Syntax.in b/misc/syntax/Syntax.in
index e8025ee..2ef521b 100644
--- a/misc/syntax/Syntax.in
+++ b/misc/syntax/Syntax.in
@@ -67,7 +67,7 @@ include tt.syntax
 file (.\*[Mm]akefile[\\\.A-Za-z0-9]\*|..\*\\.mk|..\*\\.mak|Kbuild)$ Makefile
 include makefile.syntax
 
-file CMakeLists.txt$ CMake
+file (CMakeLists.txt|.\*.cmake)$ CMake
 include cmake.syntax
 
 file ..\*\\.(pp|PP|pas|PAS|dpr|DPR|inc|INC)$ Pascal\sProgram
diff --git a/misc/syntax/cmake.syntax b/misc/syntax/cmake.syntax
index c357aad..1bf8ae0 100644
--- a/misc/syntax/cmake.syntax
+++ b/misc/syntax/cmake.syntax
@@ -2,56 +2,781 @@
 #
 # Author: Henrik Pauli <henrik.pauli@uhusystems.com>
 
-wholechars abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_
+wholechars abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-/\
 
+caseinsensitive
 context default
+
 	keyword ( brightcyan
 	keyword ) brightcyan
-	
-	keyword ${\[^}\]+} brightgreen
-	
-	keyword whole IF magenta
-	keyword whole ELSE magenta
-	keyword whole ENDIF magenta
-	
-	keyword whole cmake_minimum_required yellow
-	keyword whole PROJECT yellow
-	keyword whole SET yellow
-	keyword whole INCLUDE yellow
-	keyword whole ADD_+ yellow
-	keyword whole SET_+ yellow
-	keyword whole TARGET_+ yellow
-	keyword whole FIND_+ yellow
-	keyword whole find_+ yellow
-	keyword whole file yellow
-	keyword whole file_+ yellow
-	keyword whole configure_+ yellow
-	keyword whole install yellow
-
-	keyword whole MESSAGE brightmagenta
-	
-	keyword whole STATIC white
-	keyword whole SHARED white
-
-	keyword whole MATCHES white
-
-	keyword whole ON brightcyan
-	keyword whole OFF brightcyan
-	keyword whole NOT brightcyan
-	keyword whole DEFINED brightcyan
-
-	keyword whole NAMES white
-	keyword whole FILES white
-	keyword whole DIRECTORY white
-	keyword whole TARGETS white
-	keyword whole LIBRARY white
-	keyword whole DESTINATION white
+
+# cmake --help-command-list
+	keyword whole add_compile_options brightred
+	keyword whole add_custom_command brightred
+	keyword whole add_custom_target brightred
+	keyword whole add_definitions brightred
+	keyword whole add_dependencies brightred
+	keyword whole add_executable brightred
+	keyword whole add_library brightred
+	keyword whole add_subdirectory brightred
+	keyword whole add_test brightred
+	keyword whole aux_source_directory brightred
+	keyword whole break brightred
+	keyword whole build_command brightred
+	keyword whole cmake_host_system_information brightred
+	keyword whole cmake_minimum_required brightred
+	keyword whole cmake_policy brightred
+	keyword whole configure_file brightred
+	keyword whole create_test_sourcelist brightred
+	keyword whole define_property brightred
+	keyword whole else brightred
+	keyword whole elseif brightred
+	keyword whole enable_language brightred
+	keyword whole enable_testing brightred
+	keyword whole endforeach brightred
+	keyword whole endfunction brightred
+	keyword whole endif brightred
+	keyword whole endmacro brightred
+	keyword whole endwhile brightred
+	keyword whole execute_process brightred
+	keyword whole export brightred
+	keyword whole file brightred
+	keyword whole find_file brightred
+	keyword whole find_library brightred
+	keyword whole find_package brightred
+	keyword whole find_path brightred
+	keyword whole find_program brightred
+	keyword whole fltk_wrap_ui brightred
+	keyword whole foreach brightred
+	keyword whole function brightred
+	keyword whole get_cmake_property brightred
+	keyword whole get_directory_property brightred
+	keyword whole get_filename_component brightred
+	keyword whole get_property brightred
+	keyword whole get_source_file_property brightred
+	keyword whole get_target_property brightred
+	keyword whole get_test_property brightred
+	keyword whole if brightred
+	keyword whole include brightred
+	keyword whole include_directories brightred
+	keyword whole include_external_msproject brightred
+	keyword whole include_regular_expression brightred
+	keyword whole install brightred
+	keyword whole link_directories brightred
+	keyword whole list brightred
+	keyword whole load_cache brightred
+	keyword whole load_command brightred
+	keyword whole macro brightred
+	keyword whole mark_as_advanced brightred
+	keyword whole math brightred
+	keyword whole message brightred
+	keyword whole option brightred
+	keyword whole project brightred
+	keyword whole qt_wrap_cpp brightred
+	keyword whole qt_wrap_ui brightred
+	keyword whole remove_definitions brightred
+	keyword whole return brightred
+	keyword whole separate_arguments brightred
+	keyword whole set brightred
+	keyword whole set_directory_properties brightred
+	keyword whole set_property brightred
+	keyword whole set_source_files_properties brightred
+	keyword whole set_target_properties brightred
+	keyword whole set_tests_properties brightred
+	keyword whole site_name brightred
+	keyword whole source_group brightred
+	keyword whole string brightred
+	keyword whole target_compile_definitions brightred
+	keyword whole target_compile_options brightred
+	keyword whole target_include_directories brightred
+	keyword whole target_link_libraries brightred
+	keyword whole try_compile brightred
+	keyword whole try_run brightred
+	keyword whole unset brightred
+	keyword whole variable_watch brightred
+	keyword whole while brightred
+
+# compatibility commands
+	keyword whole build_name red
+	keyword whole exec_program red
+	keyword whole export_library_dependencies red
+	keyword whole install_files red
+	keyword whole install_programs red
+	keyword whole install_targets red
+	keyword whole link_libraries red
+	keyword whole make_directory red
+	keyword whole output_required_files red
+	keyword whole remove red
+	keyword whole subdir_depends red
+	keyword whole subdirs red
+	keyword whole use_mangled_mesa red
+	keyword whole utility_source red
+	keyword whole variable_requires red
+	keyword whole write_file red
+
+# cmake --help-property-list
+	keyword whole ALLOW_DUPLICATE_CUSTOM_TARGETS white
+	keyword whole AUTOMOC_TARGETS_FOLDER white
+	keyword whole DEBUG_CONFIGURATIONS white
+	keyword whole DISABLED_FEATURES white
+	keyword whole ENABLED_FEATURES white
+	keyword whole ENABLED_LANGUAGES white
+	keyword whole FIND_LIBRARY_USE_LIB64_PATHS white
+	keyword whole FIND_LIBRARY_USE_OPENBSD_VERSIONING white
+	keyword whole GLOBAL_DEPENDS_DEBUG_MODE white
+	keyword whole GLOBAL_DEPENDS_NO_CYCLES white
+	keyword whole IN_TRY_COMPILE white
+	keyword whole PACKAGES_FOUND white
+	keyword whole PACKAGES_NOT_FOUND white
+	keyword whole PREDEFINED_TARGETS_FOLDER white
+	keyword whole REPORT_UNDEFINED_PROPERTIES white
+	keyword whole RULE_LAUNCH_COMPILE white
+	keyword whole RULE_LAUNCH_CUSTOM white
+	keyword whole RULE_LAUNCH_LINK white
+	keyword whole RULE_MESSAGES white
+	keyword whole TARGET_ARCHIVES_MAY_BE_SHARED_LIBS white
+	keyword whole TARGET_SUPPORTS_SHARED_LIBS white
+	keyword whole USE_FOLDERS white
+	keyword whole __CMAKE_DELETE_CACHE_CHANGE_VARS_ white
+	keyword whole ADDITIONAL_MAKE_CLEAN_FILES white
+	keyword whole CACHE_VARIABLES white
+	keyword whole CLEAN_NO_CUSTOM white
+	keyword whole COMPILE_DEFINITIONS white
+	keyword whole COMPILE_DEFINITIONS_+ white
+	keyword whole COMPILE_OPTIONS white
+	keyword whole DEFINITIONS white
+	keyword whole EXCLUDE_FROM_ALL white
+	keyword whole IMPLICIT_DEPENDS_INCLUDE_TRANSFORM white
+	keyword whole INCLUDE_DIRECTORIES white
+	keyword whole INCLUDE_REGULAR_EXPRESSION white
+	keyword whole INTERPROCEDURAL_OPTIMIZATION white
+	keyword whole INTERPROCEDURAL_OPTIMIZATION_+ white
+	keyword whole LINK_DIRECTORIES white
+	keyword whole LISTFILE_STACK white
+	keyword whole MACROS white
+	keyword whole PARENT_DIRECTORY white
+	keyword whole RULE_LAUNCH_COMPILE white
+	keyword whole RULE_LAUNCH_CUSTOM white
+	keyword whole RULE_LAUNCH_LINK white
+	keyword whole TEST_INCLUDE_FILE white
+	keyword whole VARIABLES white
+	keyword whole VS_GLOBAL_SECTION_POST_+ white
+	keyword whole VS_GLOBAL_SECTION_PRE_+ white
+	keyword whole +_OUTPUT_NAME white
+	keyword whole +_POSTFIX white
+	keyword whole +_VISIBILITY_PRESET white
+	keyword whole ALIASED_TARGET white
+	keyword whole ARCHIVE_OUTPUT_DIRECTORY white
+	keyword whole ARCHIVE_OUTPUT_DIRECTORY_+ white
+	keyword whole ARCHIVE_OUTPUT_NAME white
+	keyword whole ARCHIVE_OUTPUT_NAME_+ white
+	keyword whole AUTOMOC white
+	keyword whole AUTOMOC_MOC_OPTIONS white
+	keyword whole BUILD_WITH_INSTALL_RPATH white
+	keyword whole BUNDLE white
+	keyword whole BUNDLE_EXTENSION white
+	keyword whole COMPATIBLE_INTERFACE_BOOL white
+	keyword whole COMPATIBLE_INTERFACE_STRING white
+	keyword whole COMPILE_DEFINITIONS white
+	keyword whole COMPILE_DEFINITIONS_+ white
+	keyword whole COMPILE_FLAGS white
+	keyword whole COMPILE_OPTIONS white
+	keyword whole DEBUG_POSTFIX white
+	keyword whole DEFINE_SYMBOL white
+	keyword whole ENABLE_EXPORTS white
+	keyword whole EXCLUDE_FROM_ALL white
+	keyword whole EXCLUDE_FROM_DEFAULT_BUILD white
+	keyword whole EXCLUDE_FROM_DEFAULT_BUILD_+ white
+	keyword whole EXPORT_NAME white
+	keyword whole EchoString white
+	keyword whole FOLDER white
+	keyword whole FRAMEWORK white
+	keyword whole Fortran_FORMAT white
+	keyword whole Fortran_MODULE_DIRECTORY white
+	keyword whole GENERATOR_FILE_NAME white
+	keyword whole GNUtoMS white
+	keyword whole HAS_CXX white
+	keyword whole IMPLICIT_DEPENDS_INCLUDE_TRANSFORM white
+	keyword whole IMPORTED white
+	keyword whole IMPORTED_CONFIGURATIONS white
+	keyword whole IMPORTED_IMPLIB white
+	keyword whole IMPORTED_IMPLIB_+ white
+	keyword whole IMPORTED_LINK_DEPENDENT_LIBRARIES white
+	keyword whole IMPORTED_LINK_DEPENDENT_LIBRARIES_+ white
+	keyword whole IMPORTED_LINK_INTERFACE_LANGUAGES white
+	keyword whole IMPORTED_LINK_INTERFACE_LANGUAGES_+ white
+	keyword whole IMPORTED_LINK_INTERFACE_LIBRARIES white
+	keyword whole IMPORTED_LINK_INTERFACE_LIBRARIES_+ white
+	keyword whole IMPORTED_LINK_INTERFACE_MULTIPLICITY white
+	keyword whole IMPORTED_LINK_INTERFACE_MULTIPLICITY_+ white
+	keyword whole IMPORTED_LOCATION white
+	keyword whole IMPORTED_LOCATION_+ white
+	keyword whole IMPORTED_NO_SONAME white
+	keyword whole IMPORTED_NO_SONAME_+ white
+	keyword whole IMPORTED_SONAME white
+	keyword whole IMPORTED_SONAME_+ white
+	keyword whole IMPORT_PREFIX white
+	keyword whole IMPORT_SUFFIX white
+	keyword whole INCLUDE_DIRECTORIES white
+	keyword whole INSTALL_NAME_DIR white
+	keyword whole INSTALL_RPATH white
+	keyword whole INSTALL_RPATH_USE_LINK_PATH white
+	keyword whole INTERFACE_COMPILE_DEFINITIONS white
+	keyword whole INTERFACE_COMPILE_OPTIONS white
+	keyword whole INTERFACE_INCLUDE_DIRECTORIES white
+	keyword whole INTERFACE_LINK_LIBRARIES white
+	keyword whole INTERFACE_POSITION_INDEPENDENT_CODE white
+	keyword whole INTERFACE_SYSTEM_INCLUDE_DIRECTORIES white
+	keyword whole INTERPROCEDURAL_OPTIMIZATION white
+	keyword whole INTERPROCEDURAL_OPTIMIZATION_+ white
+	keyword whole LABELS white
+	keyword whole LIBRARY_OUTPUT_DIRECTORY white
+	keyword whole LIBRARY_OUTPUT_DIRECTORY_+ white
+	keyword whole LIBRARY_OUTPUT_NAME white
+	keyword whole LIBRARY_OUTPUT_NAME_+ white
+	keyword whole LINKER_LANGUAGE white
+	keyword whole LINK_DEPENDS white
+	keyword whole LINK_DEPENDS_NO_SHARED white
+	keyword whole LINK_FLAGS white
+	keyword whole LINK_FLAGS_+ white
+	keyword whole LINK_INTERFACE_LIBRARIES white
+	keyword whole LINK_INTERFACE_LIBRARIES_+ white
+	keyword whole LINK_INTERFACE_MULTIPLICITY white
+	keyword whole LINK_INTERFACE_MULTIPLICITY_+ white
+	keyword whole LINK_LIBRARIES white
+	keyword whole LINK_SEARCH_END_STATIC white
+	keyword whole LINK_SEARCH_START_STATIC white
+	keyword whole LOCATION white
+	keyword whole LOCATION_+ white
+	keyword whole MACOSX_BUNDLE white
+	keyword whole MACOSX_BUNDLE_INFO_PLIST white
+	keyword whole MACOSX_FRAMEWORK_INFO_PLIST white
+	keyword whole MACOSX_RPATH white
+	keyword whole MAP_IMPORTED_CONFIG_+ white
+	keyword whole NAME white
+	keyword whole NO_SONAME white
+	keyword whole OSX_ARCHITECTURES white
+	keyword whole OSX_ARCHITECTURES_+ white
+	keyword whole OUTPUT_NAME white
+	keyword whole OUTPUT_NAME_+ white
+	keyword whole PDB_NAME white
+	keyword whole PDB_NAME_+ white
+	keyword whole PDB_OUTPUT_DIRECTORY white
+	keyword whole PDB_OUTPUT_DIRECTORY_+ white
+	keyword whole POSITION_INDEPENDENT_CODE white
+	keyword whole POST_INSTALL_SCRIPT white
+	keyword whole PREFIX white
+	keyword whole PRE_INSTALL_SCRIPT white
+	keyword whole PRIVATE_HEADER white
+	keyword whole PROJECT_LABEL white
+	keyword whole PUBLIC_HEADER white
+	keyword whole RESOURCE white
+	keyword whole RULE_LAUNCH_COMPILE white
+	keyword whole RULE_LAUNCH_CUSTOM white
+	keyword whole RULE_LAUNCH_LINK white
+	keyword whole RUNTIME_OUTPUT_DIRECTORY white
+	keyword whole RUNTIME_OUTPUT_DIRECTORY_+ white
+	keyword whole RUNTIME_OUTPUT_NAME white
+	keyword whole RUNTIME_OUTPUT_NAME_+ white
+	keyword whole SKIP_BUILD_RPATH white
+	keyword whole SOURCES white
+	keyword whole SOVERSION white
+	keyword whole STATIC_LIBRARY_FLAGS white
+	keyword whole STATIC_LIBRARY_FLAGS_+ white
+	keyword whole SUFFIX white
+	keyword whole TYPE white
+	keyword whole VERSION white
+	keyword whole VISIBILITY_INLINES_HIDDEN white
+	keyword whole VS_DOTNET_REFERENCES white
+	keyword whole VS_DOTNET_TARGET_FRAMEWORK_VERSION white
+	keyword whole VS_GLOBAL_+ white
+	keyword whole VS_GLOBAL_KEYWORD white
+	keyword whole VS_GLOBAL_PROJECT_TYPES white
+	keyword whole VS_GLOBAL_ROOTNAMESPACE white
+	keyword whole VS_KEYWORD white
+	keyword whole VS_SCC_AUXPATH white
+	keyword whole VS_SCC_LOCALPATH white
+	keyword whole VS_SCC_PROJECTNAME white
+	keyword whole VS_SCC_PROVIDER white
+	keyword whole VS_WINRT_EXTENSIONS white
+	keyword whole VS_WINRT_REFERENCES white
+	keyword whole WIN32_EXECUTABLE white
+	keyword whole XCODE_ATTRIBUTE_+ white
+	keyword whole ATTACHED_FILES white
+	keyword whole ATTACHED_FILES_ON_FAIL white
+	keyword whole COST white
+	keyword whole DEPENDS white
+	keyword whole ENVIRONMENT white
+	keyword whole FAIL_REGULAR_EXPRESSION white
+	keyword whole LABELS white
+	keyword whole MEASUREMENT white
+	keyword whole PASS_REGULAR_EXPRESSION white
+	keyword whole PROCESSORS white
+	keyword whole REQUIRED_FILES white
+	keyword whole RESOURCE_LOCK white
+	keyword whole RUN_SERIAL white
+	keyword whole TIMEOUT white
+	keyword whole WILL_FAIL white
+	keyword whole WORKING_DIRECTORY white
+	keyword whole ABSTRACT white
+	keyword whole COMPILE_DEFINITIONS white
+	keyword whole COMPILE_DEFINITIONS_+ white
+	keyword whole COMPILE_FLAGS white
+	keyword whole EXTERNAL_OBJECT white
+	keyword whole Fortran_FORMAT white
+	keyword whole GENERATED white
+	keyword whole HEADER_FILE_ONLY white
+	keyword whole KEEP_EXTENSION white
+	keyword whole LABELS white
+	keyword whole LANGUAGE white
+	keyword whole LOCATION white
+	keyword whole MACOSX_PACKAGE_LOCATION white
+	keyword whole OBJECT_DEPENDS white
+	keyword whole OBJECT_OUTPUTS white
+	keyword whole SYMBOLIC white
+	keyword whole WRAP_EXCLUDE white
+	keyword whole ADVANCED white
+	keyword whole HELPSTRING white
+	keyword whole MODIFIED white
+	keyword whole STRINGS white
+	keyword whole TYPE white
+	keyword whole VALUE white
+
+# cmake --help-module-list
+	keyword whole AddFileDependencies brightmagenta
+	keyword whole BundleUtilities brightmagenta
+	keyword whole CMakeAddFortranSubdirectory brightmagenta
+	keyword whole CMakeBackwardCompatibilityCXX brightmagenta
+	keyword whole CMakeDependentOption brightmagenta
+	keyword whole CMakeDetermineVSServicePack brightmagenta
+	keyword whole CMakeExpandImportedTargets brightmagenta
+	keyword whole CMakeFindFrameworks brightmagenta
+	keyword whole CMakeFindPackageMode brightmagenta
+	keyword whole CMakeForceCompiler brightmagenta
+	keyword whole CMakeGraphVizOptions brightmagenta
+	keyword whole CMakePackageConfigHelpers brightmagenta
+	keyword whole CMakeParseArguments brightmagenta
+	keyword whole CMakePrintHelpers brightmagenta
+	keyword whole CMakePrintSystemInformation brightmagenta
+	keyword whole CMakePushCheckState brightmagenta
+	keyword whole CMakeVerifyManifest brightmagenta
+	keyword whole CPack brightmagenta
+	keyword whole CPackBundle brightmagenta
+	keyword whole CPackComponent brightmagenta
+	keyword whole CPackCygwin brightmagenta
+	keyword whole CPackDMG brightmagenta
+	keyword whole CPackDeb brightmagenta
+	keyword whole CPackNSIS brightmagenta
+	keyword whole CPackPackageMaker brightmagenta
+	keyword whole CPackRPM brightmagenta
+	keyword whole CPackWIX brightmagenta
+	keyword whole CTest brightmagenta
+	keyword whole CTestScriptMode brightmagenta
+	keyword whole CTestUseLaunchers brightmagenta
+	keyword whole CheckCCompilerFlag brightmagenta
+	keyword whole CheckCSourceCompiles brightmagenta
+	keyword whole CheckCSourceRuns brightmagenta
+	keyword whole CheckCXXCompilerFlag brightmagenta
+	keyword whole CheckCXXSourceCompiles brightmagenta
+	keyword whole CheckCXXSourceRuns brightmagenta
+	keyword whole CheckCXXSymbolExists brightmagenta
+	keyword whole CheckFortranFunctionExists brightmagenta
+	keyword whole CheckFunctionExists brightmagenta
+	keyword whole CheckIncludeFile brightmagenta
+	keyword whole CheckIncludeFileCXX brightmagenta
+	keyword whole CheckIncludeFiles brightmagenta
+	keyword whole CheckLanguage brightmagenta
+	keyword whole CheckLibraryExists brightmagenta
+	keyword whole CheckPrototypeDefinition brightmagenta
+	keyword whole CheckStructHasMember brightmagenta
+	keyword whole CheckSymbolExists brightmagenta
+	keyword whole CheckTypeSize brightmagenta
+	keyword whole CheckVariableExists brightmagenta
+	keyword whole Dart brightmagenta
+	keyword whole DeployQt4 brightmagenta
+	keyword whole Documentation brightmagenta
+	keyword whole ExternalData brightmagenta
+	keyword whole ExternalProject brightmagenta
+	keyword whole FLTKConfig brightmagenta
+	keyword whole FeatureSummary brightmagenta
+	keyword whole FindALSA brightmagenta
+	keyword whole FindASPELL brightmagenta
+	keyword whole FindAVIFile brightmagenta
+	keyword whole FindArmadillo brightmagenta
+	keyword whole FindBISON brightmagenta
+	keyword whole FindBLAS brightmagenta
+	keyword whole FindBZip2 brightmagenta
+	keyword whole FindBoost brightmagenta
+	keyword whole FindBullet brightmagenta
+	keyword whole FindCABLE brightmagenta
+	keyword whole FindCUDA brightmagenta
+	keyword whole FindCURL brightmagenta
+	keyword whole FindCVS brightmagenta
+	keyword whole FindCoin3D brightmagenta
+	keyword whole FindCups brightmagenta
+	keyword whole FindCurses brightmagenta
+	keyword whole FindCxxTest brightmagenta
+	keyword whole FindCygwin brightmagenta
+	keyword whole FindDCMTK brightmagenta
+	keyword whole FindDart brightmagenta
+	keyword whole FindDevIL brightmagenta
+	keyword whole FindDoxygen brightmagenta
+	keyword whole FindEXPAT brightmagenta
+	keyword whole FindFLEX brightmagenta
+	keyword whole FindFLTK brightmagenta
+	keyword whole FindFLTK2 brightmagenta
+	keyword whole FindFreetype brightmagenta
+	keyword whole FindGCCXML brightmagenta
+	keyword whole FindGDAL brightmagenta
+	keyword whole FindGIF brightmagenta
+	keyword whole FindGLEW brightmagenta
+	keyword whole FindGLUT brightmagenta
+	keyword whole FindGTK brightmagenta
+	keyword whole FindGTK2 brightmagenta
+	keyword whole FindGTest brightmagenta
+	keyword whole FindGettext brightmagenta
+	keyword whole FindGit brightmagenta
+	keyword whole FindGnuTLS brightmagenta
+	keyword whole FindGnuplot brightmagenta
+	keyword whole FindHDF5 brightmagenta
+	keyword whole FindHSPELL brightmagenta
+	keyword whole FindHTMLHelp brightmagenta
+	keyword whole FindHg brightmagenta
+	keyword whole FindITK brightmagenta
+	keyword whole FindIcotool brightmagenta
+	keyword whole FindImageMagick brightmagenta
+	keyword whole FindJNI brightmagenta
+	keyword whole FindJPEG brightmagenta
+	keyword whole FindJasper brightmagenta
+	keyword whole FindJava brightmagenta
+	keyword whole FindKDE3 brightmagenta
+	keyword whole FindKDE4 brightmagenta
+	keyword whole FindLAPACK brightmagenta
+	keyword whole FindLATEX brightmagenta
+	keyword whole FindLibArchive brightmagenta
+	keyword whole FindLibLZMA brightmagenta
+	keyword whole FindLibXml2 brightmagenta
+	keyword whole FindLibXslt brightmagenta
+	keyword whole FindLua50 brightmagenta
+	keyword whole FindLua51 brightmagenta
+	keyword whole FindMFC brightmagenta
+	keyword whole FindMPEG brightmagenta
+	keyword whole FindMPEG2 brightmagenta
+	keyword whole FindMPI brightmagenta
+	keyword whole FindMatlab brightmagenta
+	keyword whole FindMotif brightmagenta
+	keyword whole FindOpenAL brightmagenta
+	keyword whole FindOpenGL brightmagenta
+	keyword whole FindOpenMP brightmagenta
+	keyword whole FindOpenSSL brightmagenta
+	keyword whole FindOpenSceneGraph brightmagenta
+	keyword whole FindOpenThreads brightmagenta
+	keyword whole FindPHP4 brightmagenta
+	keyword whole FindPNG brightmagenta
+	keyword whole FindPackageHandleStandardArgs brightmagenta
+	keyword whole FindPackageMessage brightmagenta
+	keyword whole FindPerl brightmagenta
+	keyword whole FindPerlLibs brightmagenta
+	keyword whole FindPhysFS brightmagenta
+	keyword whole FindPike brightmagenta
+	keyword whole FindPkgConfig brightmagenta
+	keyword whole FindPostgreSQL brightmagenta
+	keyword whole FindProducer brightmagenta
+	keyword whole FindProtobuf brightmagenta
+	keyword whole FindPythonInterp brightmagenta
+	keyword whole FindPythonLibs brightmagenta
+	keyword whole FindQt brightmagenta
+	keyword whole FindQt3 brightmagenta
+	keyword whole FindQt4 brightmagenta
+	keyword whole FindQuickTime brightmagenta
+	keyword whole FindRTI brightmagenta
+	keyword whole FindRuby brightmagenta
+	keyword whole FindSDL brightmagenta
+	keyword whole FindSDL_image brightmagenta
+	keyword whole FindSDL_mixer brightmagenta
+	keyword whole FindSDL_net brightmagenta
+	keyword whole FindSDL_sound brightmagenta
+	keyword whole FindSDL_ttf brightmagenta
+	keyword whole FindSWIG brightmagenta
+	keyword whole FindSelfPackers brightmagenta
+	keyword whole FindSquish brightmagenta
+	keyword whole FindSubversion brightmagenta
+	keyword whole FindTCL brightmagenta
+	keyword whole FindTIFF brightmagenta
+	keyword whole FindTclStub brightmagenta
+	keyword whole FindTclsh brightmagenta
+	keyword whole FindThreads brightmagenta
+	keyword whole FindUnixCommands brightmagenta
+	keyword whole FindVTK brightmagenta
+	keyword whole FindWget brightmagenta
+	keyword whole FindWish brightmagenta
+	keyword whole FindX11 brightmagenta
+	keyword whole FindXMLRPC brightmagenta
+	keyword whole FindZLIB brightmagenta
+	keyword whole Findlibproxy brightmagenta
+	keyword whole Findosg brightmagenta
+	keyword whole FindosgAnimation brightmagenta
+	keyword whole FindosgDB brightmagenta
+	keyword whole FindosgFX brightmagenta
+	keyword whole FindosgGA brightmagenta
+	keyword whole FindosgIntrospection brightmagenta
+	keyword whole FindosgManipulator brightmagenta
+	keyword whole FindosgParticle brightmagenta
+	keyword whole FindosgPresentation brightmagenta
+	keyword whole FindosgProducer brightmagenta
+	keyword whole FindosgQt brightmagenta
+	keyword whole FindosgShadow brightmagenta
+	keyword whole FindosgSim brightmagenta
+	keyword whole FindosgTerrain brightmagenta
+	keyword whole FindosgText brightmagenta
+	keyword whole FindosgUtil brightmagenta
+	keyword whole FindosgViewer brightmagenta
+	keyword whole FindosgVolume brightmagenta
+	keyword whole FindosgWidget brightmagenta
+	keyword whole Findosg_functions brightmagenta
+	keyword whole FindwxWidgets brightmagenta
+	keyword whole FindwxWindows brightmagenta
+	keyword whole FortranCInterface brightmagenta
+	keyword whole GNUInstallDirs brightmagenta
+	keyword whole GenerateExportHeader brightmagenta
+	keyword whole GetPrerequisites brightmagenta
+	keyword whole InstallRequiredSystemLibraries brightmagenta
+	keyword whole MacroAddFileDependencies brightmagenta
+	keyword whole ProcessorCount brightmagenta
+	keyword whole Qt4ConfigDependentSettings brightmagenta
+	keyword whole Qt4Macros brightmagenta
+	keyword whole SelectLibraryConfigurations brightmagenta
+	keyword whole SquishTestScript brightmagenta
+	keyword whole TestBigEndian brightmagenta
+	keyword whole TestCXXAcceptsFlag brightmagenta
+	keyword whole TestForANSIForScope brightmagenta
+	keyword whole TestForANSIStreamHeaders brightmagenta
+	keyword whole TestForSSTREAM brightmagenta
+	keyword whole TestForSTDNamespace brightmagenta
+	keyword whole UseEcos brightmagenta
+	keyword whole UseJava brightmagenta
+	keyword whole UseJavaClassFilelist brightmagenta
+	keyword whole UseJavaSymlinks brightmagenta
+	keyword whole UsePkgConfig brightmagenta
+	keyword whole UseQt4 brightmagenta
+	keyword whole UseSWIG brightmagenta
+	keyword whole Use_wxWindows brightmagenta
+	keyword whole UsewxWidgets brightmagenta
+	keyword whole WriteBasicConfigVersionFile brightmagenta
+
+# cmake --help-variable-list
+	keyword whole CMAKE_AR brightgreen
+	keyword whole CMAKE_ARGC brightgreen
+	keyword whole CMAKE_ARGV0 brightgreen
+	keyword whole CMAKE_BINARY_DIR brightgreen
+	keyword whole CMAKE_BUILD_TOOL brightgreen
+	keyword whole CMAKE_CACHEFILE_DIR brightgreen
+	keyword whole CMAKE_CACHE_MAJOR_VERSION brightgreen
+	keyword whole CMAKE_CACHE_MINOR_VERSION brightgreen
+	keyword whole CMAKE_CACHE_PATCH_VERSION brightgreen
+	keyword whole CMAKE_CFG_INTDIR brightgreen
+	keyword whole CMAKE_COMMAND brightgreen
+	keyword whole CMAKE_CROSSCOMPILING brightgreen
+	keyword whole CMAKE_CTEST_COMMAND brightgreen
+	keyword whole CMAKE_CURRENT_BINARY_DIR brightgreen
+	keyword whole CMAKE_CURRENT_LIST_DIR brightgreen
+	keyword whole CMAKE_CURRENT_LIST_FILE brightgreen
+	keyword whole CMAKE_CURRENT_LIST_LINE brightgreen
+	keyword whole CMAKE_CURRENT_SOURCE_DIR brightgreen
+	keyword whole CMAKE_DL_LIBS brightgreen
+	keyword whole CMAKE_EDIT_COMMAND brightgreen
+	keyword whole CMAKE_EXECUTABLE_SUFFIX brightgreen
+	keyword whole CMAKE_EXTRA_GENERATOR brightgreen
+	keyword whole CMAKE_EXTRA_SHARED_LIBRARY_SUFFIXES brightgreen
+	keyword whole CMAKE_GENERATOR brightgreen
+	keyword whole CMAKE_GENERATOR_TOOLSET brightgreen
+	keyword whole CMAKE_HOME_DIRECTORY brightgreen
+	keyword whole CMAKE_IMPORT_LIBRARY_PREFIX brightgreen
+	keyword whole CMAKE_IMPORT_LIBRARY_SUFFIX brightgreen
+	keyword whole CMAKE_LINK_LIBRARY_SUFFIX brightgreen
+	keyword whole CMAKE_MAJOR_VERSION brightgreen
+	keyword whole CMAKE_MAKE_PROGRAM brightgreen
+	keyword whole CMAKE_MINIMUM_REQUIRED_VERSION brightgreen
+	keyword whole CMAKE_MINOR_VERSION brightgreen
+	keyword whole CMAKE_PARENT_LIST_FILE brightgreen
+	keyword whole CMAKE_PATCH_VERSION brightgreen
+	keyword whole CMAKE_PROJECT_NAME brightgreen
+	keyword whole CMAKE_RANLIB brightgreen
+	keyword whole CMAKE_ROOT brightgreen
+	keyword whole CMAKE_SCRIPT_MODE_FILE brightgreen
+	keyword whole CMAKE_SHARED_LIBRARY_PREFIX brightgreen
+	keyword whole CMAKE_SHARED_LIBRARY_SUFFIX brightgreen
+	keyword whole CMAKE_SHARED_MODULE_PREFIX brightgreen
+	keyword whole CMAKE_SHARED_MODULE_SUFFIX brightgreen
+	keyword whole CMAKE_SIZEOF_VOID_P brightgreen
+	keyword whole CMAKE_SKIP_RPATH brightgreen
+	keyword whole CMAKE_SOURCE_DIR brightgreen
+	keyword whole CMAKE_STANDARD_LIBRARIES brightgreen
+	keyword whole CMAKE_STATIC_LIBRARY_PREFIX brightgreen
+	keyword whole CMAKE_STATIC_LIBRARY_SUFFIX brightgreen
+	keyword whole CMAKE_TWEAK_VERSION brightgreen
+	keyword whole CMAKE_VERBOSE_MAKEFILE brightgreen
+	keyword whole CMAKE_VERSION brightgreen
+	keyword whole CMAKE_VS_PLATFORM_TOOLSET brightgreen
+	keyword whole CMAKE_XCODE_PLATFORM_TOOLSET brightgreen
+	keyword whole PROJECT_BINARY_DIR brightgreen
+	keyword whole PROJECT_NAME brightgreen
+	keyword whole PROJECT_SOURCE_DIR brightgreen
+	keyword whole +_BINARY_DIR brightgreen
+	keyword whole +_SOURCE_DIR brightgreen
+	keyword whole BUILD_SHARED_LIBS brightgreen
+	keyword whole CMAKE_ABSOLUTE_DESTINATION_FILES brightgreen
+	keyword whole CMAKE_AUTOMOC_RELAXED_MODE brightgreen
+	keyword whole CMAKE_BACKWARDS_COMPATIBILITY brightgreen
+	keyword whole CMAKE_BUILD_TYPE brightgreen
+	keyword whole CMAKE_COLOR_MAKEFILE brightgreen
+	keyword whole CMAKE_CONFIGURATION_TYPES brightgreen
+	keyword whole CMAKE_DEBUG_TARGET_PROPERTIES brightgreen
+	keyword whole CMAKE_DISABLE_FIND_PACKAGE_+ brightgreen
+	keyword whole CMAKE_ERROR_DEPRECATED brightgreen
+	keyword whole CMAKE_ERROR_ON_ABSOLUTE_INSTALL_DESTINATION brightgreen
+	keyword whole CMAKE_FIND_LIBRARY_PREFIXES brightgreen
+	keyword whole CMAKE_FIND_LIBRARY_SUFFIXES brightgreen
+	keyword whole CMAKE_FIND_PACKAGE_WARN_NO_MODULE brightgreen
+	keyword whole CMAKE_IGNORE_PATH brightgreen
+	keyword whole CMAKE_INCLUDE_PATH brightgreen
+	keyword whole CMAKE_INSTALL_DEFAULT_COMPONENT_NAME brightgreen
+	keyword whole CMAKE_INSTALL_PREFIX brightgreen
+	keyword whole CMAKE_LIBRARY_PATH brightgreen
+	keyword whole CMAKE_MFC_FLAG brightgreen
+	keyword whole CMAKE_MODULE_PATH brightgreen
+	keyword whole CMAKE_NOT_USING_CONFIG_FLAGS brightgreen
+	keyword whole CMAKE_POLICY_DEFAULT_CMP+ brightgreen
+	keyword whole CMAKE_PREFIX_PATH brightgreen
+	keyword whole CMAKE_PROGRAM_PATH brightgreen
+	keyword whole CMAKE_SKIP_INSTALL_ALL_DEPENDENCY brightgreen
+	keyword whole CMAKE_SYSTEM_IGNORE_PATH brightgreen
+	keyword whole CMAKE_SYSTEM_INCLUDE_PATH brightgreen
+	keyword whole CMAKE_SYSTEM_LIBRARY_PATH brightgreen
+	keyword whole CMAKE_SYSTEM_PREFIX_PATH brightgreen
+	keyword whole CMAKE_SYSTEM_PROGRAM_PATH brightgreen
+	keyword whole CMAKE_USER_MAKE_RULES_OVERRIDE brightgreen
+	keyword whole CMAKE_WARN_DEPRECATED brightgreen
+	keyword whole CMAKE_WARN_ON_ABSOLUTE_INSTALL_DESTINATION brightgreen
+	keyword whole APPLE brightgreen
+	keyword whole BORLAND brightgreen
+	keyword whole CMAKE_CL_64 brightgreen
+	keyword whole CMAKE_COMPILER_2005 brightgreen
+	keyword whole CMAKE_HOST_APPLE brightgreen
+	keyword whole CMAKE_HOST_SYSTEM brightgreen
+	keyword whole CMAKE_HOST_SYSTEM_NAME brightgreen
+	keyword whole CMAKE_HOST_SYSTEM_PROCESSOR brightgreen
+	keyword whole CMAKE_HOST_SYSTEM_VERSION brightgreen
+	keyword whole CMAKE_HOST_UNIX brightgreen
+	keyword whole CMAKE_HOST_WIN32 brightgreen
+	keyword whole CMAKE_LIBRARY_ARCHITECTURE brightgreen
+	keyword whole CMAKE_LIBRARY_ARCHITECTURE_REGEX brightgreen
+	keyword whole CMAKE_OBJECT_PATH_MAX brightgreen
+	keyword whole CMAKE_SYSTEM brightgreen
+	keyword whole CMAKE_SYSTEM_NAME brightgreen
+	keyword whole CMAKE_SYSTEM_PROCESSOR brightgreen
+	keyword whole CMAKE_SYSTEM_VERSION brightgreen
+	keyword whole CYGWIN brightgreen
+	keyword whole ENV brightgreen
+	keyword whole MSVC brightgreen
+	keyword whole MSVC10 brightgreen
+	keyword whole MSVC11 brightgreen
+	keyword whole MSVC12 brightgreen
+	keyword whole MSVC60 brightgreen
+	keyword whole MSVC70 brightgreen
+	keyword whole MSVC71 brightgreen
+	keyword whole MSVC80 brightgreen
+	keyword whole MSVC90 brightgreen
+	keyword whole MSVC_IDE brightgreen
+	keyword whole MSVC_VERSION brightgreen
+	keyword whole UNIX brightgreen
+	keyword whole WIN32 brightgreen
+	keyword whole XCODE_VERSION brightgreen
+	keyword whole CMAKE_+_POSTFIX brightgreen
+	keyword whole CMAKE_+_VISIBILITY_PRESET brightgreen
+	keyword whole CMAKE_ARCHIVE_OUTPUT_DIRECTORY brightgreen
+	keyword whole CMAKE_AUTOMOC brightgreen
+	keyword whole CMAKE_AUTOMOC_MOC_OPTIONS brightgreen
+	keyword whole CMAKE_BUILD_WITH_INSTALL_RPATH brightgreen
+	keyword whole CMAKE_DEBUG_POSTFIX brightgreen
+	keyword whole CMAKE_EXE_LINKER_FLAGS brightgreen
+	keyword whole CMAKE_EXE_LINKER_FLAGS_+ brightgreen
+	keyword whole CMAKE_Fortran_FORMAT brightgreen
+	keyword whole CMAKE_Fortran_MODULE_DIRECTORY brightgreen
+	keyword whole CMAKE_GNUtoMS brightgreen
+	keyword whole CMAKE_INCLUDE_CURRENT_DIR brightgreen
+	keyword whole CMAKE_INCLUDE_CURRENT_DIR_IN_INTERFACE brightgreen
+	keyword whole CMAKE_INSTALL_NAME_DIR brightgreen
+	keyword whole CMAKE_INSTALL_RPATH brightgreen
+	keyword whole CMAKE_INSTALL_RPATH_USE_LINK_PATH brightgreen
+	keyword whole CMAKE_LIBRARY_OUTPUT_DIRECTORY brightgreen
+	keyword whole CMAKE_LIBRARY_PATH_FLAG brightgreen
+	keyword whole CMAKE_LINK_DEF_FILE_FLAG brightgreen  
+	keyword whole CMAKE_LINK_DEPENDS_NO_SHARED brightgreen
+	keyword whole CMAKE_LINK_INTERFACE_LIBRARIES brightgreen
+	keyword whole CMAKE_LINK_LIBRARY_FILE_FLAG brightgreen
+	keyword whole CMAKE_LINK_LIBRARY_FLAG brightgreen
+	keyword whole CMAKE_MACOSX_BUNDLE brightgreen
+	keyword whole CMAKE_MODULE_LINKER_FLAGS brightgreen
+	keyword whole CMAKE_MODULE_LINKER_FLAGS_+ brightgreen
+	keyword whole CMAKE_NO_BUILTIN_CHRPATH brightgreen
+	keyword whole CMAKE_PDB_OUTPUT_DIRECTORY brightgreen
+	keyword whole CMAKE_POSITION_INDEPENDENT_CODE brightgreen
+	keyword whole CMAKE_RUNTIME_OUTPUT_DIRECTORY brightgreen
+	keyword whole CMAKE_SHARED_LINKER_FLAGS brightgreen
+	keyword whole CMAKE_SHARED_LINKER_FLAGS_+ brightgreen
+	keyword whole CMAKE_SKIP_BUILD_RPATH brightgreen
+	keyword whole CMAKE_SKIP_INSTALL_RPATH brightgreen
+	keyword whole CMAKE_STATIC_LINKER_FLAGS brightgreen
+	keyword whole CMAKE_STATIC_LINKER_FLAGS_+ brightgreen
+	keyword whole CMAKE_TRY_COMPILE_CONFIGURATION brightgreen
+	keyword whole CMAKE_USE_RELATIVE_PATHS brightgreen
+	keyword whole CMAKE_VISIBILITY_INLINES_HIDDEN brightgreen
+	keyword whole CMAKE_WIN32_EXECUTABLE brightgreen
+	keyword whole EXECUTABLE_OUTPUT_PATH brightgreen
+	keyword whole LIBRARY_OUTPUT_PATH brightgreen
+	keyword whole CMAKE_+_ARCHIVE_APPEND brightgreen
+	keyword whole CMAKE_+_ARCHIVE_CREATE brightgreen
+	keyword whole CMAKE_+_ARCHIVE_FINISH brightgreen
+	keyword whole CMAKE_+_COMPILER brightgreen
+	keyword whole CMAKE_+_COMPILER_ABI brightgreen
+	keyword whole CMAKE_+_COMPILER_ID brightgreen
+	keyword whole CMAKE_+_COMPILER_LOADED brightgreen
+	keyword whole CMAKE_+_COMPILER_VERSION brightgreen
+	keyword whole CMAKE_+_COMPILE_OBJECT brightgreen
+	keyword whole CMAKE_+_CREATE_SHARED_LIBRARY brightgreen
+	keyword whole CMAKE_+_CREATE_SHARED_MODULE brightgreen
+	keyword whole CMAKE_+_CREATE_STATIC_LIBRARY brightgreen
+	keyword whole CMAKE_+_FLAGS brightgreen
+	keyword whole CMAKE_+_FLAGS_DEBUG brightgreen
+	keyword whole CMAKE_+_FLAGS_MINSIZEREL brightgreen
+	keyword whole CMAKE_+_FLAGS_RELEASE brightgreen
+	keyword whole CMAKE_+_FLAGS_RELWITHDEBINFO brightgreen
+	keyword whole CMAKE_+_IGNORE_EXTENSIONS brightgreen
+	keyword whole CMAKE_+_IMPLICIT_INCLUDE_DIRECTORIES brightgreen
+	keyword whole CMAKE_+_IMPLICIT_LINK_DIRECTORIES brightgreen
+	keyword whole CMAKE_+_IMPLICIT_LINK_FRAMEWORK_DIRECTORIES brightgreen
+	keyword whole CMAKE_+_IMPLICIT_LINK_LIBRARIES brightgreen
+	keyword whole CMAKE_+_LIBRARY_ARCHITECTURE brightgreen
+	keyword whole CMAKE_+_LINKER_PREFERENCE brightgreen
+	keyword whole CMAKE_+_LINKER_PREFERENCE_PROPAGATES brightgreen
+	keyword whole CMAKE_+_LINK_EXECUTABLE brightgreen
+	keyword whole CMAKE_+_OUTPUT_EXTENSION brightgreen
+	keyword whole CMAKE_+_PLATFORM_ID brightgreen
+	keyword whole CMAKE_+_SIZEOF_DATA_PTR brightgreen
+	keyword whole CMAKE_+_SOURCE_FILE_EXTENSIONS brightgreen
+	keyword whole CMAKE_COMPILER_IS_GNU+ brightgreen
+	keyword whole CMAKE_Fortran_MODDIR_DEFAULT brightgreen
+	keyword whole CMAKE_Fortran_MODDIR_FLAG brightgreen
+	keyword whole CMAKE_Fortran_MODOUT_FLAG brightgreen
+	keyword whole CMAKE_INTERNAL_PLATFORM_ABI brightgreen
+	keyword whole CMAKE_USER_MAKE_RULES_OVERRIDE_+ brightgreen
+
+	keyword ${*} brightgreen
 
 	spellcheck
 
 context # \n brown
 
 context " " green
-	keyword ${\[^}\]+} brightgreen
-
-	spellcheck
+	keyword ${*} brightgreen
diff --git a/po/az.po b/po/az.po
index 297de9b..c18e42b 100644
Binary files a/po/az.po and b/po/az.po differ
diff --git a/po/be.po b/po/be.po
index 02961be..3fda5b2 100644
Binary files a/po/be.po and b/po/be.po differ
diff --git a/po/bg.po b/po/bg.po
index f679b77..e3d089f 100644
Binary files a/po/bg.po and b/po/bg.po differ
diff --git a/po/ca.po b/po/ca.po
index 9900786..608c95b 100644
Binary files a/po/ca.po and b/po/ca.po differ
diff --git a/po/cs.po b/po/cs.po
index 6fa3a3f..41b960d 100644
Binary files a/po/cs.po and b/po/cs.po differ
diff --git a/po/da.po b/po/da.po
index 6dea60d..2333ec9 100644
Binary files a/po/da.po and b/po/da.po differ
diff --git a/po/de.po b/po/de.po
index b1e76aa..7c62cfd 100644
Binary files a/po/de.po and b/po/de.po differ
diff --git a/po/de_CH.po b/po/de_CH.po
index e2755d5..d78e015 100644
Binary files a/po/de_CH.po and b/po/de_CH.po differ
diff --git a/po/el.po b/po/el.po
index 6dad6ed..7034a46 100644
Binary files a/po/el.po and b/po/el.po differ
diff --git a/po/en_GB.po b/po/en_GB.po
index 309de5d..d0886a1 100644
Binary files a/po/en_GB.po and b/po/en_GB.po differ
diff --git a/po/eo.po b/po/eo.po
index 5c61a43..a0741d2 100644
Binary files a/po/eo.po and b/po/eo.po differ
diff --git a/po/es.po b/po/es.po
index 7333be1..741aa6b 100644
Binary files a/po/es.po and b/po/es.po differ
diff --git a/po/et.po b/po/et.po
index 9d8d104..83ce9b9 100644
Binary files a/po/et.po and b/po/et.po differ
diff --git a/po/eu.po b/po/eu.po
index 169833d..6dd7737 100644
Binary files a/po/eu.po and b/po/eu.po differ
diff --git a/po/fa.po b/po/fa.po
index c3653fe..fca2446 100644
Binary files a/po/fa.po and b/po/fa.po differ
diff --git a/po/fi.po b/po/fi.po
index b7fd353..8133557 100644
Binary files a/po/fi.po and b/po/fi.po differ
diff --git a/po/fi_FI.po b/po/fi_FI.po
index a576570..bcf3862 100644
Binary files a/po/fi_FI.po and b/po/fi_FI.po differ
diff --git a/po/fr.po b/po/fr.po
index dfddca5..7cffd98 100644
Binary files a/po/fr.po and b/po/fr.po differ
diff --git a/po/gl.po b/po/gl.po
index 9aa3ea1..2a3b0d6 100644
Binary files a/po/gl.po and b/po/gl.po differ
diff --git a/po/hr.po b/po/hr.po
index c4f5aa0..d2f5461 100644
Binary files a/po/hr.po and b/po/hr.po differ
diff --git a/po/hu.po b/po/hu.po
index a2078ac..252d786 100644
Binary files a/po/hu.po and b/po/hu.po differ
diff --git a/po/ia.po b/po/ia.po
index 4b8160c..171a2b5 100644
Binary files a/po/ia.po and b/po/ia.po differ
diff --git a/po/id.po b/po/id.po
index ea6e0cb..e2e92c0 100644
Binary files a/po/id.po and b/po/id.po differ
diff --git a/po/it.po b/po/it.po
index 13790e4..5f4f138 100644
Binary files a/po/it.po and b/po/it.po differ
diff --git a/po/ja.po b/po/ja.po
index 51d506f..1df7b85 100644
Binary files a/po/ja.po and b/po/ja.po differ
diff --git a/po/ka.po b/po/ka.po
index dc163db..b7e0ae9 100644
Binary files a/po/ka.po and b/po/ka.po differ
diff --git a/po/kk.po b/po/kk.po
index f8cf247..b5e2434 100644
Binary files a/po/kk.po and b/po/kk.po differ
diff --git a/po/ko.po b/po/ko.po
index 08b1781..303fe9b 100644
Binary files a/po/ko.po and b/po/ko.po differ
diff --git a/po/lt.po b/po/lt.po
index abeb623..1f973f6 100644
Binary files a/po/lt.po and b/po/lt.po differ
diff --git a/po/lv.po b/po/lv.po
index ce80afc..346be35 100644
Binary files a/po/lv.po and b/po/lv.po differ
diff --git a/po/mc.pot b/po/mc.pot
index 0a52fb1..10ff758 100644
--- a/po/mc.pot
+++ b/po/mc.pot
@@ -5,9 +5,9 @@
 #
 msgid ""
 msgstr ""
-"Project-Id-Version: mc 4.8.12-74-g394cde3\n"
+"Project-Id-Version: mc 4.8.12-83-gc88fb51\n"
 "Report-Msgid-Bugs-To: http://www.midnight-commander.org/\n"
-"POT-Creation-Date: 2014-07-22 14:35+0400\n"
+"POT-Creation-Date: 2014-07-25 10:37+0400\n"
 "PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
 "Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
 "Language-Team: LANGUAGE <LL@li.org>\n"
@@ -557,7 +557,7 @@ msgstr ""
 #: src/editor/editcmd.c:3459 src/editor/editcmd.c:3488
 #: src/editor/editcmd_dialogs.c:479 src/execute.c:135
 #: src/filemanager/file.c:1674 src/filemanager/panel.c:4361 src/help.c:362
-#: src/main.c:406 src/subshell.c:378 src/subshell.c:1050
+#: src/main.c:406 src/subshell.c:378 src/subshell.c:1053
 #: src/viewer/actions_cmd.c:419
 msgid "Warning"
 msgstr ""
@@ -670,7 +670,7 @@ msgstr ""
 #: src/filemanager/filegui.c:438 src/filemanager/hotlist.c:1121
 #: src/filemanager/hotlist.c:1138 src/filemanager/midnight.c:1037
 #: src/filemanager/midnight.c:1045 src/filemanager/panel.c:2723
-#: src/filemanager/tree.c:880 src/subshell.c:1052 src/viewer/actions_cmd.c:616
+#: src/filemanager/tree.c:880 src/subshell.c:1055 src/viewer/actions_cmd.c:616
 #: src/viewer/actions_cmd.c:622 src/viewer/search.c:358
 msgid "&Yes"
 msgstr ""
@@ -682,7 +682,7 @@ msgstr ""
 #: src/filemanager/filegui.c:440 src/filemanager/hotlist.c:1121
 #: src/filemanager/hotlist.c:1138 src/filemanager/midnight.c:1037
 #: src/filemanager/midnight.c:1045 src/filemanager/panel.c:2723
-#: src/filemanager/tree.c:880 src/subshell.c:1052 src/viewer/actions_cmd.c:616
+#: src/filemanager/tree.c:880 src/subshell.c:1055 src/viewer/actions_cmd.c:616
 #: src/viewer/actions_cmd.c:622 src/viewer/search.c:359
 msgid "&No"
 msgstr ""
@@ -2034,6 +2034,102 @@ msgstr ""
 msgid "ButtonBar|PullDn"
 msgstr ""
 
+#: src/editor/spell.c:100
+msgid "Breton"
+msgstr ""
+
+#: src/editor/spell.c:101
+msgid "Czech"
+msgstr ""
+
+#: src/editor/spell.c:102
+msgid "Welsh"
+msgstr ""
+
+#: src/editor/spell.c:103
+msgid "Danish"
+msgstr ""
+
+#: src/editor/spell.c:104
+msgid "German"
+msgstr ""
+
+#: src/editor/spell.c:105
+msgid "Greek"
+msgstr ""
+
+#: src/editor/spell.c:106
+msgid "English"
+msgstr ""
+
+#: src/editor/spell.c:107
+msgid "British English"
+msgstr ""
+
+#: src/editor/spell.c:108
+msgid "Canadian English"
+msgstr ""
+
+#: src/editor/spell.c:109
+msgid "American English"
+msgstr ""
+
+#: src/editor/spell.c:110
+msgid "Esperanto"
+msgstr ""
+
+#: src/editor/spell.c:111
+msgid "Spanish"
+msgstr ""
+
+#: src/editor/spell.c:112
+msgid "Faroese"
+msgstr ""
+
+#: src/editor/spell.c:113
+msgid "French"
+msgstr ""
+
+#: src/editor/spell.c:114
+msgid "Italian"
+msgstr ""
+
+#: src/editor/spell.c:115
+msgid "Dutch"
+msgstr ""
+
+#: src/editor/spell.c:116
+msgid "Norwegian"
+msgstr ""
+
+#: src/editor/spell.c:117
+msgid "Polish"
+msgstr ""
+
+#: src/editor/spell.c:118
+msgid "Portuguese"
+msgstr ""
+
+#: src/editor/spell.c:119
+msgid "Romanian"
+msgstr ""
+
+#: src/editor/spell.c:120
+msgid "Russian"
+msgstr ""
+
+#: src/editor/spell.c:121
+msgid "Slovak"
+msgstr ""
+
+#: src/editor/spell.c:122
+msgid "Swedish"
+msgstr ""
+
+#: src/editor/spell.c:123
+msgid "Ukrainian"
+msgstr ""
+
 #: src/editor/spell_dialogs.c:94
 msgid "&Add word"
 msgstr ""
@@ -4599,11 +4695,11 @@ msgstr ""
 msgid "Cannot open named pipe %s\n"
 msgstr ""
 
-#: src/subshell.c:1051
+#: src/subshell.c:1054
 msgid "The shell is still active. Quit anyway?"
 msgstr ""
 
-#: src/subshell.c:1219
+#: src/subshell.c:1222
 #, c-format
 msgid "Warning: Cannot change to %s.\n"
 msgstr ""
diff --git a/po/mn.po b/po/mn.po
index bbc5d89..6b2930c 100644
Binary files a/po/mn.po and b/po/mn.po differ
diff --git a/po/nb.po b/po/nb.po
index a3581b1..5e6085a 100644
Binary files a/po/nb.po and b/po/nb.po differ
diff --git a/po/nl.po b/po/nl.po
index 47285de..16ca96f 100644
Binary files a/po/nl.po and b/po/nl.po differ
diff --git a/po/pl.po b/po/pl.po
index d49b3f2..3215d1b 100644
Binary files a/po/pl.po and b/po/pl.po differ
diff --git a/po/pt.po b/po/pt.po
index cc6ab14..43f398a 100644
Binary files a/po/pt.po and b/po/pt.po differ
diff --git a/po/pt_BR.po b/po/pt_BR.po
index 8241cd9..a79f9c5 100644
Binary files a/po/pt_BR.po and b/po/pt_BR.po differ
diff --git a/po/ro.po b/po/ro.po
index 83d6746..0e8db21 100644
Binary files a/po/ro.po and b/po/ro.po differ
diff --git a/po/ru.po b/po/ru.po
index 5e48797..5ff268d 100644
Binary files a/po/ru.po and b/po/ru.po differ
diff --git a/po/sk.po b/po/sk.po
index 673642d..5a0b4f5 100644
Binary files a/po/sk.po and b/po/sk.po differ
diff --git a/po/sl.po b/po/sl.po
index dc35be4..4d88cb7 100644
Binary files a/po/sl.po and b/po/sl.po differ
diff --git a/po/sr.po b/po/sr.po
index 6efc325..2b4c5d0 100644
Binary files a/po/sr.po and b/po/sr.po differ
diff --git a/po/sv.po b/po/sv.po
index ee06474..badbb7a 100644
Binary files a/po/sv.po and b/po/sv.po differ
diff --git a/po/sv_SE.po b/po/sv_SE.po
index a47b603..ca541a8 100644
Binary files a/po/sv_SE.po and b/po/sv_SE.po differ
diff --git a/po/szl.po b/po/szl.po
index 8af239d..e8c5969 100644
Binary files a/po/szl.po and b/po/szl.po differ
diff --git a/po/ta.po b/po/ta.po
index dc6989d..cb63d2b 100644
Binary files a/po/ta.po and b/po/ta.po differ
diff --git a/po/tr.po b/po/tr.po
index 07ee566..c350b5f 100644
Binary files a/po/tr.po and b/po/tr.po differ
diff --git a/po/uk.po b/po/uk.po
index c21bda4..23f6628 100644
Binary files a/po/uk.po and b/po/uk.po differ
diff --git a/po/vi.po b/po/vi.po
index dcdb126..182b13f 100644
Binary files a/po/vi.po and b/po/vi.po differ
diff --git a/po/wa.po b/po/wa.po
index ff5ff34..3723914 100644
Binary files a/po/wa.po and b/po/wa.po differ
diff --git a/po/zh_CN.po b/po/zh_CN.po
index 5cac6ad..be0b5db 100644
Binary files a/po/zh_CN.po and b/po/zh_CN.po differ
diff --git a/po/zh_TW.po b/po/zh_TW.po
index 3f9c2fe..9c70e23 100644
Binary files a/po/zh_TW.po and b/po/zh_TW.po differ
diff --git a/src/args.c b/src/args.c
index f1f7f34..72c6bbe 100644
--- a/src/args.c
+++ b/src/args.c
@@ -409,7 +409,11 @@ mc_args_add_extended_info_to_help (void)
                                                    ("\n"
                                                     "Please send any bug reports (including the output of 'mc -V')\n"
                                                     "as tickets at www.midnight-commander.org\n"));
+#if defined(BUILD_NUMBER) //WIN32/APY, build
+    mc_args__loc__header_string = g_strdup_printf (_("GNU Midnight Commander %s (build: %s)\n"), VERSION, BUILD_NUMBER);
+#else
     mc_args__loc__header_string = g_strdup_printf (_("GNU Midnight Commander %s\n"), VERSION);
+#endif
 
     g_option_context_set_description (context, mc_args__loc__footer_string);
     g_option_context_set_summary (context, mc_args__loc__header_string);
diff --git a/src/cons.handler.c b/src/cons.handler.c
index dcf9d17..457dac2 100644
--- a/src/cons.handler.c
+++ b/src/cons.handler.c
@@ -463,6 +463,8 @@ show_console_contents (int starty, unsigned char begin_line, unsigned char end_l
     show_console_contents_linux (starty, begin_line, end_line);
 #elif defined (__FreeBSD__)
     show_console_contents_freebsd (starty, begin_line, end_line);
+#elif defined (WIN32)
+    show_console_contents_win32 (starty, begin_line, end_line);
 #else
     mc_global.tty.console_flag = '\0';
 #endif
@@ -482,6 +484,8 @@ handle_console (console_action_t action)
     handle_console_linux (action);
 #elif defined (__FreeBSD__)
     handle_console_freebsd (action);
+#elif defined (WIN32)
+    handle_console_win32 (action);
 #endif
 }
 
diff --git a/src/diffviewer/search.c b/src/diffviewer/search.c
index 35efa57..5626eab 100644
--- a/src/diffviewer/search.c
+++ b/src/diffviewer/search.c
@@ -80,6 +80,14 @@ mcdiffview_dialog_search (WDiff * dview)
     list_of_types = mc_search_get_types_strings_array (&num_of_types);
 
     {
+#if defined(WIN32)  //WIN32, quick
+#ifdef HAVE_CHARSET
+        quick_widget_t quick_widgets[12],
+#else
+        quick_widget_t quick_widgets[11],
+#endif
+            *qc = quick_widgets;
+#else
         quick_widget_t quick_widgets[] = {
             /* *INDENT-OFF* */
             QUICK_LABELED_INPUT (N_("Enter search string:"), input_label_above, INPUT_LAST_TEXT,
@@ -100,6 +108,8 @@ mcdiffview_dialog_search (WDiff * dview)
             QUICK_END
             /* *INDENT-ON* */
         };
+#endif  //WIN32
+
 
         quick_dialog_t qdlg = {
             -1, -1, 58,
@@ -107,6 +117,27 @@ mcdiffview_dialog_search (WDiff * dview)
             quick_widgets, NULL, NULL
         };
 
+#if defined(WIN32)  //WIN32, quick
+        qc = XQUICK_LABELED_INPUT (qc,
+                                    N_("Enter search string:"), input_label_above, INPUT_LAST_TEXT,
+                                    MC_HISTORY_SHARED_SEARCH, &exp, NULL, FALSE, FALSE, INPUT_COMPLETE_NONE),
+        qc = XQUICK_SEPARATOR (qc, TRUE);
+        qc = XQUICK_START_COLUMNS (qc);
+        qc =    XQUICK_RADIO (qc, num_of_types, (const char **) list_of_types,
+                                  (int *) &mcdiffview_search_options.type, NULL);
+        qc = XQUICK_NEXT_COLUMN (qc);
+        qc =    XQUICK_CHECKBOX (qc, N_("Cas&e sensitive"), &mcdiffview_search_options.case_sens, NULL);
+        qc =    XQUICK_CHECKBOX (qc, N_("&Backwards"), &mcdiffview_search_options.backwards, NULL);
+        qc =    XQUICK_CHECKBOX (qc, N_("&Whole words"), &mcdiffview_search_options.whole_words, NULL);
+#ifdef HAVE_CHARSET
+        qc =    XQUICK_CHECKBOX (qc, N_("&All charsets"), &mcdiffview_search_options.all_codepages, NULL);
+#endif
+        qc = XQUICK_STOP_COLUMNS (qc);
+        qc = XQUICK_BUTTONS_OK_CANCEL (qc);
+        qc = XQUICK_END (qc);
+        assert(qc == (quick_widgets + (sizeof(quick_widgets)/sizeof(quick_widgets[0]))));
+#endif
+
         qd_result = quick_dialog (&qdlg);
     }
 
diff --git a/src/diffviewer/ydiff.c b/src/diffviewer/ydiff.c
index 54415bf..c6b6bbd 100644
--- a/src/diffviewer/ydiff.c
+++ b/src/diffviewer/ydiff.c
@@ -2354,6 +2354,10 @@ dview_diff_options (WDiff * dview)
         N_("&Minimal (Find a smaller set of change)")
     };
 
+#if defined(WIN32)  //WIN32, quick
+    quick_widget_t quick_widgets[12],
+        *qc = quick_widgets;
+#else
     quick_widget_t quick_widgets[] = {
         /* *INDENT-OFF* */
         QUICK_START_GROUPBOX (N_("Diff algorithm")),
@@ -2371,6 +2375,7 @@ dview_diff_options (WDiff * dview)
         QUICK_END
         /* *INDENT-ON* */
     };
+#endif  //WIN32
 
     quick_dialog_t qdlg = {
         -1, -1, 56,
@@ -2378,6 +2383,22 @@ dview_diff_options (WDiff * dview)
         quick_widgets, NULL, NULL
     };
 
+#if defined(WIN32)  //WIN32, quick
+    qc = XQUICK_START_GROUPBOX (qc, N_("Diff algorithm"));
+    qc =     XQUICK_RADIO (qc, 3, (const char **) quality_str, (int *) &dview->opt.quality, NULL);
+    qc = XQUICK_STOP_GROUPBOX (qc);
+    qc = XQUICK_START_GROUPBOX (qc, N_("Diff extra options"));
+    qc =     XQUICK_CHECKBOX (qc, N_("&Ignore case"), &dview->opt.ignore_case, NULL);
+    qc =     XQUICK_CHECKBOX (qc, N_("Ignore tab &expansion"), &dview->opt.ignore_tab_expansion, NULL);
+    qc =     XQUICK_CHECKBOX (qc, N_("Ignore &space change"), &dview->opt.ignore_space_change, NULL);
+    qc =     XQUICK_CHECKBOX (qc, N_("Ignore all &whitespace"), &dview->opt.ignore_all_space, NULL);
+    qc =     XQUICK_CHECKBOX (qc, N_("Strip &trailing carriage return"), &dview->opt.strip_trailing_cr, NULL);
+    qc = XQUICK_STOP_GROUPBOX (qc);
+    qc = XQUICK_BUTTONS_OK_CANCEL (qc);
+    qc = XQUICK_END (qc);
+    assert(qc == (quick_widgets + (sizeof(quick_widgets)/sizeof(quick_widgets[0]))));
+#endif
+
     if (quick_dialog (&qdlg) != B_CANCEL)
         dview_reread (dview);
 }
diff --git a/src/editor/editcmd.c b/src/editor/editcmd.c
index dcd1a3c..a2beab4 100644
--- a/src/editor/editcmd.c
+++ b/src/editor/editcmd.c
@@ -72,6 +72,7 @@
 #endif
 #include "src/keybind-defaults.h"
 #include "src/util.h"           /* check_for_default() */
+#include "src/filemanager/layout.h"     /* mc_refresh()  */
 
 #include "edit-impl.h"
 #include "editwidget.h"
@@ -456,6 +457,10 @@ edit_get_save_file_as (WEdit * edit)
         N_("&Macintosh format (CR)")
     };
 
+#if defined(WIN32)  //WIN32, quick
+        quick_widget_t quick_widgets[6+2],
+            *qc = quick_widgets;
+#else
     quick_widget_t quick_widgets[] = {
         /* *INDENT-OFF* */
         QUICK_LABELED_INPUT (N_("Enter file name:"), input_label_above,
@@ -468,6 +473,7 @@ edit_get_save_file_as (WEdit * edit)
         QUICK_END
         /* *INDENT-ON* */
     };
+#endif  //WIN32
 
     quick_dialog_t qdlg = {
         -1, -1, 64,
@@ -475,6 +481,18 @@ edit_get_save_file_as (WEdit * edit)
         quick_widgets, NULL, NULL
     };
 
+#if defined(WIN32)  //WIN32, quick
+        qc = XQUICK_LABELED_INPUT (qc, N_("Enter file name:"), input_label_above,
+                             vfs_path_as_str (edit->filename_vpath), "save-as",
+                             &filename_res, NULL, FALSE, FALSE, INPUT_COMPLETE_FILENAMES),
+        qc = XQUICK_SEPARATOR (qc, TRUE),
+        qc = XQUICK_LABEL (qc, N_("Change line breaks to:"), NULL);
+        qc = XQUICK_RADIO (qc, LB_NAMES, lb_names, (int *) &cur_lb, NULL);
+        qc = XQUICK_BUTTONS_OK_CANCEL (qc);
+        qc = XQUICK_END (qc);
+        assert(qc == (quick_widgets + (sizeof(quick_widgets)/sizeof(quick_widgets[0]))));
+#endif  //WIN32
+
     if (quick_dialog (&qdlg) != B_CANCEL)
     {
         char *fname;
@@ -1644,6 +1662,10 @@ edit_save_mode_cmd (void)
 #endif
 
     {
+#if defined(WIN32)  //WIN32, quick
+        quick_widget_t quick_widgets[6+2],
+            *qc = quick_widgets;
+#else
         quick_widget_t quick_widgets[] = {
             /* *INDENT-OFF* */
             QUICK_RADIO (3, str, &option_save_mode, &edit_save_mode_radio_id),
@@ -1655,6 +1677,7 @@ edit_save_mode_cmd (void)
             QUICK_END
             /* *INDENT-ON* */
         };
+#endif  //WIN32
 
         quick_dialog_t qdlg = {
             -1, -1, 38,
@@ -1662,6 +1685,18 @@ edit_save_mode_cmd (void)
             quick_widgets, edit_save_mode_callback, NULL
         };
 
+#if defined(WIN32)  //WIN32, quick
+        qc = XQUICK_RADIO (qc, 3, str, &option_save_mode, &edit_save_mode_radio_id),
+        qc = XQUICK_INPUT (qc,
+                            option_backup_ext, "edit-backup-ext", &str_result,
+                            &edit_save_mode_input_id, FALSE, FALSE, INPUT_COMPLETE_NONE);
+        qc = XQUICK_SEPARATOR (qc, TRUE);
+        qc = XQUICK_CHECKBOX (qc, N_("Check &POSIX new line"), &option_check_nl_at_eof, NULL);
+        qc = XQUICK_BUTTONS_OK_CANCEL (qc);
+        qc = XQUICK_END (qc);
+        assert(qc == (quick_widgets + (sizeof(quick_widgets)/sizeof(quick_widgets[0]))));
+#endif  //WIN32
+
         if (quick_dialog (&qdlg) != B_CANCEL)
         {
             g_free (option_backup_ext);
@@ -3292,7 +3327,10 @@ edit_mail_dialog (WEdit * edit)
     static char *mail_subject_last = 0;
     static char *mail_to_last = 0;
 
-
+#if defined(WIN32)  //WIN32, quick
+    quick_widget_t quick_widgets[6+2],
+        *qc = quick_widgets;
+#else
     quick_widget_t quick_widgets[] = {
         /* *INDENT-OFF* */
         QUICK_LABEL (N_("mail -s <subject> -c <cc> <to>"), NULL),
@@ -3300,8 +3338,8 @@ edit_mail_dialog (WEdit * edit)
                              mail_to_last != NULL ? mail_to_last : "", "mail-dlg-input-3",
                              &tmail_to, NULL, FALSE, FALSE, INPUT_COMPLETE_USERNAMES),
         QUICK_LABELED_INPUT (N_("Subject"), input_label_above,
-                              mail_subject_last != NULL ? mail_subject_last : "", "mail-dlg-input-2",
-                              &tmail_subject, NULL, FALSE, FALSE, INPUT_COMPLETE_NONE),
+                             mail_subject_last != NULL ? mail_subject_last : "", "mail-dlg-input-2",
+                             &tmail_subject, NULL, FALSE, FALSE, INPUT_COMPLETE_NONE),
         QUICK_LABELED_INPUT (N_("Copies to"), input_label_above,
                              mail_cc_last != NULL ? mail_cc_last  : "", "mail-dlg-input",
                              &tmail_cc, NULL, FALSE, FALSE, INPUT_COMPLETE_USERNAMES),
@@ -3309,6 +3347,7 @@ edit_mail_dialog (WEdit * edit)
         QUICK_END
         /* *INDENT-ON* */
     };
+#endif  //WIN32
 
     quick_dialog_t qdlg = {
         -1, -1, 50,
@@ -3316,6 +3355,22 @@ edit_mail_dialog (WEdit * edit)
         quick_widgets, NULL, NULL
     };
 
+#if defined(WIN32)  //WIN32, quick
+    qc = XQUICK_LABEL (qc, N_("mail -s <subject> -c <cc> <to>"), NULL);
+    qc = XQUICK_LABELED_INPUT (qc, N_("To"), input_label_above,
+                             mail_to_last != NULL ? mail_to_last : "", "mail-dlg-input-3",
+                             &tmail_to, NULL, FALSE, FALSE, INPUT_COMPLETE_USERNAMES),
+    qc = XQUICK_LABELED_INPUT (qc, N_("Subject"), input_label_above,
+                             mail_subject_last != NULL ? mail_subject_last : "", "mail-dlg-input-2",
+                             &tmail_subject, NULL, FALSE, FALSE, INPUT_COMPLETE_NONE),
+    qc = XQUICK_LABELED_INPUT (qc, N_("Copies to"), input_label_above,
+                             mail_cc_last != NULL ? mail_cc_last  : "", "mail-dlg-input",
+                             &tmail_cc, NULL, FALSE, FALSE, INPUT_COMPLETE_USERNAMES),
+   qc = XQUICK_BUTTONS_OK_CANCEL (qc);
+    qc = XQUICK_END (qc);
+    assert(qc == (quick_widgets + (sizeof(quick_widgets)/sizeof(quick_widgets[0]))));
+#endif  //WIN32
+
     if (quick_dialog (&qdlg) != B_CANCEL)
     {
         g_free (mail_cc_last);
diff --git a/src/editor/editcmd_dialogs.c b/src/editor/editcmd_dialogs.c
index 6744df6..8a11a0f 100644
--- a/src/editor/editcmd_dialogs.c
+++ b/src/editor/editcmd_dialogs.c
@@ -99,6 +99,14 @@ editcmd_dialog_search_show (WEdit * edit)
     list_of_types = mc_search_get_types_strings_array (&num_of_types);
 
     {
+#if defined(WIN32)  //WIN32, quick
+#ifdef HAVE_CHARSET
+        quick_widget_t quick_widgets[16],
+#else
+        quick_widget_t quick_widgets[15],
+#endif
+            *qc = quick_widgets;
+#else
         quick_widget_t quick_widgets[] = {
             /* *INDENT-OFF* */
             QUICK_LABELED_INPUT (N_("Enter search string:"), input_label_above, INPUT_LAST_TEXT, 
@@ -124,6 +132,7 @@ editcmd_dialog_search_show (WEdit * edit)
             QUICK_END
             /* *INDENT-ON* */
         };
+#endif  //WIN332
 
         quick_dialog_t qdlg = {
             -1, -1, 58,
@@ -131,6 +140,32 @@ editcmd_dialog_search_show (WEdit * edit)
             quick_widgets, NULL, NULL
         };
 
+#if defined(WIN32)  //WIN32, quick
+        qc = XQUICK_LABELED_INPUT (qc,
+                                   N_("Enter search string:"), input_label_above, INPUT_LAST_TEXT, 
+                                  MC_HISTORY_SHARED_SEARCH, &search_text, NULL, FALSE, FALSE,
+                                  INPUT_COMPLETE_NONE);
+        qc = XQUICK_SEPARATOR (qc, TRUE);
+        qc = XQUICK_START_COLUMNS (qc);
+        qc =      XQUICK_RADIO (qc, num_of_types, (const char **) list_of_types,
+                                    (int *) &edit_search_options.type, NULL);
+        qc = XQUICK_NEXT_COLUMN (qc);
+        qc =      XQUICK_CHECKBOX (qc, N_("Cas&e sensitive"), &edit_search_options.case_sens, NULL);
+        qc =      XQUICK_CHECKBOX (qc, N_("&Backwards"), &edit_search_options.backwards, NULL);
+        qc =      XQUICK_CHECKBOX (qc, N_("In se&lection"), &edit_search_options.only_in_selection, NULL);
+        qc =      XQUICK_CHECKBOX (qc, N_("&Whole words"), &edit_search_options.whole_words, NULL);
+#ifdef HAVE_CHARSET
+        qc =     XQUICK_CHECKBOX (qc, N_("&All charsets"), &edit_search_options.all_codepages, NULL);
+#endif
+        qc = XQUICK_STOP_COLUMNS (qc);
+        qc = XQUICK_START_BUTTONS (qc, TRUE, TRUE);
+        qc =      XQUICK_BUTTON (qc, N_("&OK"), B_ENTER, NULL, NULL);
+        qc =      XQUICK_BUTTON (qc, N_("&Find all"), B_USER, NULL, NULL);
+        qc =      XQUICK_BUTTON (qc, N_("&Cancel"), B_CANCEL, NULL, NULL);
+        qc = XQUICK_END (qc);
+        assert(qc == (quick_widgets + (sizeof(quick_widgets)/sizeof(quick_widgets[0]))));
+#endif  //WIN32
+
         dialog_result = quick_dialog (&qdlg);
     }
 
@@ -197,6 +232,14 @@ editcmd_dialog_replace_show (WEdit * edit, const char *search_default, const cha
     list_of_types = mc_search_get_types_strings_array (&num_of_types);
 
     {
+#if defined(WIN32)  //WIN32, quick
+#ifdef HAVE_CHARSET
+        quick_widget_t quick_widgets[14+2],
+#else
+        quick_widget_t quick_widgets[13+2],
+#endif
+            *qc = quick_widgets;
+#else
         quick_widget_t quick_widgets[] = {
             /* *INDENT-OFF* */
             QUICK_LABELED_INPUT (N_("Enter search string:"), input_label_above, search_default,
@@ -221,6 +264,7 @@ editcmd_dialog_replace_show (WEdit * edit, const char *search_default, const cha
             QUICK_END
             /* *INDENT-ON* */
         };
+#endif  //WIN332
 
         quick_dialog_t qdlg = {
             -1, -1, 58,
@@ -228,6 +272,32 @@ editcmd_dialog_replace_show (WEdit * edit, const char *search_default, const cha
             quick_widgets, NULL, NULL
         };
 
+#if defined(WIN32)  //WIN32, quick
+        qc = XQUICK_LABELED_INPUT (qc,
+                                    N_("Enter search string:"), input_label_above, search_default,
+                                    MC_HISTORY_SHARED_SEARCH, search_text, NULL, FALSE, FALSE,
+                                    INPUT_COMPLETE_NONE);
+        qc = XQUICK_LABELED_INPUT (qc,
+                                    N_("Enter replacement string:"), input_label_above, replace_default,
+                                    "replace", replace_text, NULL, FALSE, FALSE, INPUT_COMPLETE_NONE);
+        qc = XQUICK_SEPARATOR (qc, TRUE);
+        qc = XQUICK_START_COLUMNS (qc);
+        qc =    XQUICK_RADIO (qc, num_of_types, (const char **) list_of_types,
+                                  (int *) &edit_search_options.type, NULL);
+        qc = XQUICK_NEXT_COLUMN (qc);
+        qc =    XQUICK_CHECKBOX (qc, N_("Cas&e sensitive"), &edit_search_options.case_sens, NULL);
+        qc =    XQUICK_CHECKBOX (qc, N_("&Backwards"), &edit_search_options.backwards, NULL);
+        qc =    XQUICK_CHECKBOX (qc, N_("In se&lection"), &edit_search_options.only_in_selection, NULL);
+        qc =    XQUICK_CHECKBOX (qc, N_("&Whole words"), &edit_search_options.whole_words, NULL);
+#ifdef HAVE_CHARSET
+        qc =    XQUICK_CHECKBOX (qc, N_("&All charsets"), &edit_search_options.all_codepages, NULL);
+#endif
+        qc = XQUICK_STOP_COLUMNS (qc);
+        qc = XQUICK_BUTTONS_OK_CANCEL (qc);
+        qc = XQUICK_END (qc);
+        assert(qc == (quick_widgets + (sizeof(quick_widgets)/sizeof(quick_widgets[0]))));
+#endif  //WIN32
+
         if (quick_dialog (&qdlg) != B_CANCEL)
             edit->replace_mode = 0;
         else
@@ -273,6 +343,10 @@ editcmd_dialog_replace_prompt_show (WEdit * edit, char *from_text, char *to_text
     repl_to = g_strdup (str_trunc (tmp, dlg_width - 7));
 
     {
+#if defined(WIN32)  //WIN32, quick
+        quick_widget_t quick_widgets[9],
+            *qc = quick_widgets;
+#else
         quick_widget_t quick_widgets[] = {
             /* *INDENT-OFF* */
             QUICK_LABEL (repl_from, NULL),
@@ -286,6 +360,7 @@ editcmd_dialog_replace_prompt_show (WEdit * edit, char *from_text, char *to_text
             QUICK_END
             /* *INDENT-ON* */
         };
+#endif  //WIN332
 
         quick_dialog_t qdlg = {
             ypos, xpos, -1,
@@ -293,6 +368,20 @@ editcmd_dialog_replace_prompt_show (WEdit * edit, char *from_text, char *to_text
             quick_widgets, NULL, NULL
         };
 
+#if defined(WIN32)  //WIN32, quick
+        qc = XQUICK_LABEL (qc, repl_from, NULL);
+        qc = XQUICK_LABEL (qc, N_("Replace with:"), NULL);
+        qc = XQUICK_LABEL (qc, repl_to, NULL);
+        qc = XQUICK_START_BUTTONS (qc, TRUE, TRUE);
+        qc =      XQUICK_BUTTON (qc, N_("&Replace"), B_ENTER, NULL, NULL);
+        qc =      XQUICK_BUTTON (qc, N_("A&ll"), B_REPLACE_ALL, NULL, NULL);
+        qc =      XQUICK_BUTTON (qc, N_("&Skip"), B_SKIP_REPLACE, NULL, NULL);
+        qc =      XQUICK_BUTTON (qc, N_("&Cancel"), B_CANCEL, NULL, NULL);
+        qc = XQUICK_END (qc);
+        assert(qc == (quick_widgets + (sizeof(quick_widgets)/sizeof(quick_widgets[0]))));
+#endif  //WIN32
+
+
         retval = quick_dialog (&qdlg);
     }
 
diff --git a/src/editor/editoptions.c b/src/editor/editoptions.c
index f870346..8bcb5dd 100644
--- a/src/editor/editoptions.c
+++ b/src/editor/editoptions.c
@@ -33,6 +33,7 @@
 #include <config.h>
 
 #include <stdlib.h>             /* atoi(), NULL */
+#include <assert.h>             //WIN32, quick
 
 #include "lib/global.h"
 #include "lib/widget.h"
@@ -142,6 +143,10 @@ edit_options_dialog (WDialog * h)
         wrap_mode = 0;
 
     {
+#if defined(WIN32)  //WIN32, quick
+        quick_widget_t quick_widgets[28],
+            *qc = quick_widgets;
+#else
         quick_widget_t quick_widgets[] = {
             /* *INDENT-OFF* */
             QUICK_START_COLUMNS,
@@ -182,6 +187,7 @@ edit_options_dialog (WDialog * h)
             QUICK_END
             /* *INDENT-ON* */
         };
+#endif  //WIN32
 
         quick_dialog_t qdlg = {
             -1, -1, 74,
@@ -189,6 +195,42 @@ edit_options_dialog (WDialog * h)
             quick_widgets, NULL, NULL
         };
 
+#if defined(WIN32)  //WIN32, quick
+        qc = XQUICK_START_COLUMNS (qc);
+        qc =     XQUICK_START_GROUPBOX (qc, N_("Wrap mode"));
+        qc =         XQUICK_RADIO (qc, 3, wrap_str, &wrap_mode, NULL);
+        qc =     XQUICK_STOP_GROUPBOX (qc);
+        qc =     XQUICK_SEPARATOR (qc, FALSE);
+        qc =     XQUICK_START_GROUPBOX (qc, N_("Tabulation"));
+        qc =         XQUICK_CHECKBOX (qc, N_("&Fake half tabs"), &option_fake_half_tabs, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("&Backspace through tabs"), &option_backspace_through_tabs, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("Fill tabs with &spaces"), &option_fill_tabs_with_spaces, NULL),
+        qc =         XQUICK_LABELED_INPUT (qc,
+                                            N_("Tab spacing:"), input_label_left, tab_spacing,
+                                            "edit-tab-spacing", &q, NULL, FALSE, FALSE, INPUT_COMPLETE_NONE);
+        qc =     XQUICK_STOP_GROUPBOX (qc);
+        qc = XQUICK_NEXT_COLUMN (qc);
+        qc =     XQUICK_START_GROUPBOX (qc, N_("Other options")),
+        qc =         XQUICK_CHECKBOX (qc, N_("&Return does autoindent"), &option_return_does_auto_indent, NULL); 
+        qc =         XQUICK_CHECKBOX (qc, N_("Confir&m before saving"), &edit_confirm_save, NULL); 
+        qc =         XQUICK_CHECKBOX (qc, N_("Save file &position"), &option_save_position, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("&Visible trailing spaces"), &visible_tws, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("Visible &tabs"), &visible_tabs, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("Synta&x highlighting"), &option_syntax_highlighting, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("C&ursor after inserted block"), &option_cursor_after_inserted_block, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("Pers&istent selection"), &option_persistent_selections, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("Cursor be&yond end of line"), &option_cursor_beyond_eol, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("&Group undo"), &option_group_undo, NULL);
+        qc =         XQUICK_LABELED_INPUT (qc,
+                                            N_("Word wrap line length:"), input_label_left, wrap_length,
+                                            "edit-word-wrap", &p, NULL, FALSE, FALSE, INPUT_COMPLETE_NONE);
+        qc =     XQUICK_STOP_GROUPBOX (qc);
+        qc = XQUICK_STOP_COLUMNS (qc);
+        qc = XQUICK_BUTTONS_OK_CANCEL (qc);
+        qc = XQUICK_END (qc);
+        assert(qc == (quick_widgets + (sizeof(quick_widgets)/sizeof(quick_widgets[0]))));
+#endif  //WIN32
+
         if (quick_dialog (&qdlg) == B_CANCEL)
             return;
     }
diff --git a/src/editor/spell.c b/src/editor/spell.c
index d213873..0c86bf0 100644
--- a/src/editor/spell.c
+++ b/src/editor/spell.c
@@ -25,6 +25,8 @@
 
 #include <config.h>
 
+#if defined(HAVE_ASPELL) //WIN32
+
 #include <stdlib.h>
 #include <string.h>
 #include <gmodule.h>
@@ -97,30 +99,30 @@ static struct
 } spell_codes_map[] =
 {
     /* *INDENT-OFF* */
-    {"br", "Breton"},
-    {"cs", "Czech"},
-    {"cy", "Welsh"},
-    {"da", "Danish"},
-    {"de", "German"},
-    {"el", "Greek"},
-    {"en", "English"},
-    {"en_GB", "British English"},
-    {"en_CA", "Canadian English"},
-    {"en_US", "American English"},
-    {"eo", "Esperanto"},
-    {"es", "Spanish"},
-    {"fo", "Faroese"},
-    {"fr", "French"},
-    {"it", "Italian"},
-    {"nl", "Dutch"},
-    {"no", "Norwegian"},
-    {"pl", "Polish"},
-    {"pt", "Portuguese"},
-    {"ro", "Romanian"},
-    {"ru", "Russian"},
-    {"sk", "Slovak"},
-    {"sv", "Swedish"},
-    {"uk", "Ukrainian"},
+    {"br", N_("Breton")},
+    {"cs", N_("Czech")},
+    {"cy", N_("Welsh")},
+    {"da", N_("Danish")},
+    {"de", N_("German")},
+    {"el", N_("Greek")},
+    {"en", N_("English")},
+    {"en_GB", N_("British English")},
+    {"en_CA", N_("Canadian English")},
+    {"en_US", N_("American English")},
+    {"eo", N_("Esperanto")},
+    {"es", N_("Spanish")},
+    {"fo", N_("Faroese")},
+    {"fr", N_("French")},
+    {"it", N_("Italian")},
+    {"nl", N_("Dutch")},
+    {"no", N_("Norwegian")},
+    {"pl", N_("Polish")},
+    {"pt", N_("Portuguese")},
+    {"ro", N_("Romanian")},
+    {"ru", N_("Russian")},
+    {"sk", N_("Slovak")},
+    {"sv", N_("Swedish")},
+    {"uk", N_("Ukrainian")},
     {NULL, NULL}
     /* *INDENT-ON* */
 };
@@ -142,7 +144,7 @@ spell_decode_lang (const char *code)
     for (i = 0; spell_codes_map[i].code != NULL; i++)
     {
         if (strcmp (spell_codes_map[i].code, code) == 0)
-            return spell_codes_map[i].name;
+            return _(spell_codes_map[i].name);
     }
 
     return code;
@@ -567,4 +569,6 @@ aspell_add_to_dict (const char *word, int word_size)
     return TRUE;
 }
 
+#endif  //HAVE_ASPELL
+
 /* --------------------------------------------------------------------------------------------- */
diff --git a/src/editor/spell_dialogs.c b/src/editor/spell_dialogs.c
index c650944..7895fab 100644
--- a/src/editor/spell_dialogs.c
+++ b/src/editor/spell_dialogs.c
@@ -102,7 +102,11 @@ spell_dialog_spell_suggest_show (WEdit * edit, const char *word, char **new_word
     max_btn_len = max (replace_len, skip_len);
     max_btn_len = max (max_btn_len, cancel_len);
 
+#if defined(HAVE_ASPELL) //WIN32
     lang_label = g_strdup_printf ("%s: %s", _("Language"), aspell_get_lang ());
+#else
+    lang_label = g_strdup_printf ("%s: %s", _("Language"), "n/a");
+#endif
     word_label = g_strdup_printf ("%s: %s", _("Misspelled"), word);
     word_label_len = str_term_width1 (word_label) + 5;
 
diff --git a/src/filemanager/boxes.c b/src/filemanager/boxes.c
index 28bf221..4be38a4 100644
--- a/src/filemanager/boxes.c
+++ b/src/filemanager/boxes.c
@@ -58,7 +58,7 @@
 #include "lib/util.h"           /* Q_() */
 #include "lib/widget.h"
 
-#include "src/setup.h"
+#include "src/setup.h"          /* For profile_name */
 #include "src/history.h"        /* MC_HISTORY_ESC_TIMEOUT */
 #include "src/execute.h"        /* pause_after_run */
 #ifdef ENABLE_BACKGROUND
@@ -443,6 +443,10 @@ configure_box (void)
         char time_out[BUF_TINY] = "";
         char *time_out_new;
 
+#if defined(WIN32)  //WIN32, quick
+        quick_widget_t quick_widgets[35+2],
+            *qc = quick_widgets;
+#else
         quick_widget_t quick_widgets[] = {
             /* *INDENT-OFF* */
             QUICK_START_COLUMNS,
@@ -488,6 +492,7 @@ configure_box (void)
             QUICK_END
             /* *INDENT-ON* */
         };
+#endif  //WIN32
 
         quick_dialog_t qdlg = {
             -1, -1, 60,
@@ -495,6 +500,50 @@ configure_box (void)
             quick_widgets, configure_callback, NULL
         };
 
+#if defined(WIN32)  //WIN32, quick
+        qc = XQUICK_START_COLUMNS (qc);
+        qc =     XQUICK_START_GROUPBOX (qc, N_("File operations"));
+        qc =         XQUICK_CHECKBOX (qc, N_("&Verbose operation"), &verbose, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("Compute tota&ls"), &file_op_compute_totals, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("Classic pro&gressbar"), &classic_progressbar, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("Mkdi&r autoname"), &auto_fill_mkdir_name, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("&Preallocate space"), &mc_global.vfs.preallocate_space,
+                                          NULL);
+        qc =     XQUICK_STOP_GROUPBOX (qc);
+        qc =     XQUICK_START_GROUPBOX (qc, N_("Esc key mode"));
+        qc =         XQUICK_CHECKBOX (qc, N_("S&ingle press"), &old_esc_mode, &configure_old_esc_mode_id);
+        qc =         XQUICK_LABELED_INPUT (qc,
+                                         N_("Timeout:"), input_label_left,
+                                         (const char *) time_out, MC_HISTORY_ESC_TIMEOUT,
+                                         &time_out_new, &configure_time_out_id, FALSE, FALSE,
+                                         INPUT_COMPLETE_NONE);
+        qc =     XQUICK_STOP_GROUPBOX (qc);
+        qc =     XQUICK_START_GROUPBOX (qc, N_("Pause after run"));
+        qc =         XQUICK_RADIO (qc, pause_options_num, pause_options, &pause_after_run, NULL);
+        qc =     XQUICK_STOP_GROUPBOX (qc);
+        qc = XQUICK_NEXT_COLUMN (qc);
+        qc =     XQUICK_START_GROUPBOX (qc, N_("Other options"));
+        qc =         XQUICK_CHECKBOX (qc, N_("Use internal edi&t"), &use_internal_edit, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("Use internal vie&w"), &use_internal_view, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("Auto m&enus"), &auto_menu, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("&Drop down menus"), &drop_menus, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("S&hell &patterns"), &easy_patterns, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("Co&mplete: show all"), &mc_global.widget.show_all_if_ambiguous, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("Rotating d&ash"), &nice_rotating_dash, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("Cd follows lin&ks"), &mc_global.vfs.cd_symlinks, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("Sa&fe delete"), &safe_delete, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("A&uto save setup"), &auto_save_setup, NULL);
+        qc =         XQUICK_SEPARATOR (qc, FALSE);
+        qc =         XQUICK_SEPARATOR (qc, FALSE);
+        qc =         XQUICK_SEPARATOR (qc, FALSE);
+        qc =         XQUICK_SEPARATOR (qc, FALSE);
+        qc =     XQUICK_STOP_GROUPBOX (qc);
+        qc = XQUICK_STOP_COLUMNS (qc);
+        qc = XQUICK_BUTTONS_OK_CANCEL (qc);
+        qc = XQUICK_END (qc);
+        assert(qc == (quick_widgets + (sizeof(quick_widgets)/sizeof(quick_widgets[0]))));
+#endif
+
         g_snprintf (time_out, sizeof (time_out), "%d", old_esc_mode_timeout);
 
 #ifndef USE_INTERNAL_EDIT
@@ -620,6 +669,10 @@ appearance_box (void)
     skin_names = mc_skin_list ();
 
     {
+#if defined(WIN32)  //WIN32, quick
+        quick_widget_t quick_widgets[7+2],
+            *qc = quick_widgets;
+#else
         quick_widget_t quick_widgets[] = {
             /* *INDENT-OFF* */
             QUICK_START_COLUMNS,
@@ -632,6 +685,7 @@ appearance_box (void)
             QUICK_END
             /* *INDENT-ON* */
         };
+#endif
 
         quick_dialog_t qdlg = {
             -1, -1, 54,
@@ -639,6 +693,18 @@ appearance_box (void)
             quick_widgets, dlg_default_callback, NULL
         };
 
+#if defined(WIN32)  //WIN32, quick
+        qc = XQUICK_START_COLUMNS (qc);
+        qc =     XQUICK_LABEL (qc, N_("Skin:"), NULL);
+        qc = XQUICK_NEXT_COLUMN (qc);
+        qc =     XQUICK_BUTTON (qc, str_fit_to_term (skin_name_to_label (current_skin_name), 20, J_LEFT_FIT),
+                              B_USER, sel_skin_button, &skin_name_id);
+        qc = XQUICK_STOP_COLUMNS (qc);
+        qc = XQUICK_BUTTONS_OK_CANCEL (qc);
+        qc = XQUICK_END (qc);
+        assert(qc == (quick_widgets + (sizeof(quick_widgets)/sizeof(quick_widgets[0]))));
+#endif
+
         if (quick_dialog (&qdlg) == B_ENTER)
             mc_config_set_string (mc_main_config, CONFIG_APP_SECTION, "skin", current_skin_name);
         else
@@ -666,6 +732,10 @@ panel_options_box (void)
             N_("Use panel sort mo&de")
         };
 
+#if defined(WIN32)  //WIN32, quick
+        quick_widget_t quick_widgets[31+2],
+            *qc = quick_widgets;
+#else
         quick_widget_t quick_widgets[] = {
             /* *INDENT-OFF* */
             QUICK_START_COLUMNS,
@@ -706,6 +776,7 @@ panel_options_box (void)
             QUICK_END
             /* *INDENT-ON* */
         };
+#endif  //WIN32
 
         quick_dialog_t qdlg = {
             -1, -1, 60,
@@ -713,6 +784,41 @@ panel_options_box (void)
             quick_widgets, NULL, NULL
         };
 
+#if defined(WIN32)  //WIN32, quick
+        qc = XQUICK_START_COLUMNS (qc);
+        qc =     XQUICK_START_GROUPBOX (qc, N_("Main options"));
+        qc =         XQUICK_CHECKBOX (qc, N_("Show mi&ni-status"), &panels_options.show_mini_info, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("Use SI si&ze units"), &panels_options.kilobyte_si, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("Mi&x all files"), &panels_options.mix_all_files, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("Show &backup files"), &panels_options.show_backups, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("Show &hidden files"), &panels_options.show_dot_files, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("&Fast dir reload"), &panels_options.fast_reload, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("Ma&rk moves down"), &panels_options.mark_moves_down, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("Re&verse files only"), &panels_options.reverse_files_only, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("Simple s&wap"), &simple_swap, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("A&uto save panels setup"), &panels_options.auto_save_setup, NULL);
+        qc =         XQUICK_SEPARATOR (qc, FALSE);
+        qc =         XQUICK_SEPARATOR (qc, FALSE);
+        qc =     XQUICK_STOP_GROUPBOX (qc);
+        qc = XQUICK_NEXT_COLUMN (qc);
+        qc =     XQUICK_START_GROUPBOX (qc, N_("Navigation"));
+        qc =         XQUICK_CHECKBOX (qc, N_("L&ynx-like motion"), &panels_options.navigate_with_arrows, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("Pa&ge scrolling"), &panels_options.scroll_pages, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("&Mouse page scrolling"), &panels_options.mouse_move_pages, NULL);
+        qc =     XQUICK_STOP_GROUPBOX (qc);
+        qc =     XQUICK_START_GROUPBOX (qc, N_("File highlight"));
+        qc =         XQUICK_CHECKBOX (qc, N_("File &types"), &panels_options.filetype_mode, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("&Permissions"), &panels_options.permission_mode, NULL);
+        qc =     XQUICK_STOP_GROUPBOX (qc);
+        qc =     XQUICK_START_GROUPBOX (qc, N_("Quick search"));
+        qc =         XQUICK_RADIO (qc, QSEARCH_NUM, qsearch_options, (int *) &panels_options.qsearch_mode, NULL);
+        qc =     XQUICK_STOP_GROUPBOX (qc);
+        qc = XQUICK_STOP_COLUMNS (qc);
+        qc = XQUICK_BUTTONS_OK_CANCEL (qc);
+        qc = XQUICK_END (qc);
+        assert(qc == (quick_widgets + (sizeof(quick_widgets)/sizeof(quick_widgets[0]))));
+#endif  //WIN32
+
         if (quick_dialog (&qdlg) != B_ENTER)
             return;
     }
@@ -777,6 +883,10 @@ panel_listing_box (WPanel * panel, char **userp, char **minip, int *use_msformat
             N_("&User defined:")
         };
 
+#if defined(WIN32)  //WIN32, quick
+        quick_widget_t quick_widgets[7+2],
+            *qc = quick_widgets;
+#else
         quick_widget_t quick_widgets[] = {
             /* *INDENT-OFF* */
             QUICK_RADIO (LIST_TYPES, list_types, &result, &panel_listing_types_id),
@@ -790,6 +900,7 @@ panel_listing_box (WPanel * panel, char **userp, char **minip, int *use_msformat
             QUICK_END
             /* *INDENT-ON* */
         };
+#endif  //WIN32, quick
 
         quick_dialog_t qdlg = {
             -1, -1, 48,
@@ -797,6 +908,21 @@ panel_listing_box (WPanel * panel, char **userp, char **minip, int *use_msformat
             quick_widgets, panel_listing_callback, NULL
         };
 
+#if defined(WIN32)  //WIN32, quick
+        qc = XQUICK_RADIO (qc, LIST_TYPES, list_types, &result, &panel_listing_types_id);
+        qc = XQUICK_INPUT (qc,
+                            panel->user_format, "user-fmt-input", &panel_user_format,
+                            &panel_user_format_id, FALSE, FALSE, INPUT_COMPLETE_NONE);
+        qc = XQUICK_SEPARATOR (qc, TRUE);
+        qc = XQUICK_CHECKBOX (qc, N_("User &mini status"), &mini_user_status, &mini_user_status_id);
+        qc = XQUICK_INPUT (qc,
+                            panel->user_status_format[panel->list_type], "mini_input",
+                            &mini_user_format, &mini_user_format_id, FALSE, FALSE, INPUT_COMPLETE_NONE);
+        qc = XQUICK_BUTTONS_OK_CANCEL (qc);
+        qc = XQUICK_END (qc);
+        assert(qc == (quick_widgets + (sizeof(quick_widgets)/sizeof(quick_widgets[0]))));
+#endif  //WIN32, quick
+
         /* get hotkey of user-defined format string */
         cp = strchr (_(list_types[panel_listing_user_idx]), '&');
         if (cp != NULL && *++cp != '\0')
@@ -855,6 +981,10 @@ sort_box (dir_sort_options_t * op, const panel_field_t * sort_field)
         }
 
     {
+#if defined(WIN32)  //WIN32, quick
+        quick_widget_t quick_widgets[9+2],
+            *qc = quick_widgets;
+#else
         quick_widget_t quick_widgets[] = {
             /* *INDENT-OFF* */
             QUICK_START_COLUMNS,
@@ -868,6 +998,7 @@ sort_box (dir_sort_options_t * op, const panel_field_t * sort_field)
             QUICK_END
             /* *INDENT-ON* */
         };
+#endif  //WIN32, quick
 
         quick_dialog_t qdlg = {
             -1, -1, 40,
@@ -875,6 +1006,19 @@ sort_box (dir_sort_options_t * op, const panel_field_t * sort_field)
             quick_widgets, NULL, NULL
         };
 
+#if defined(WIN32)  //WIN32, quick
+        qc = XQUICK_START_COLUMNS (qc);
+        qc =    XQUICK_RADIO (qc, sort_names_num, sort_orders_names, &sort_idx, NULL);
+        qc = XQUICK_NEXT_COLUMN (qc);
+        qc =    XQUICK_CHECKBOX (qc, N_("Executable &first"), &op->exec_first, NULL);
+        qc =    XQUICK_CHECKBOX (qc, N_("Cas&e sensitive"), &op->case_sensitive, NULL);
+        qc =    XQUICK_CHECKBOX (qc, N_("&Reverse"), &op->reverse, NULL);
+        qc = XQUICK_STOP_COLUMNS (qc);
+        qc = XQUICK_BUTTONS_OK_CANCEL (qc);
+        qc = XQUICK_END (qc);
+        assert(qc == (quick_widgets + (sizeof(quick_widgets)/sizeof(quick_widgets[0]))));
+#endif  //WIN32, quick
+
         if (quick_dialog (&qdlg) != B_CANCEL)
             result = panel_get_field_by_title_hotkey (sort_orders_names[sort_idx]);
 
@@ -892,6 +1036,10 @@ sort_box (dir_sort_options_t * op, const panel_field_t * sort_field)
 void
 confirm_box (void)
 {
+#if defined(WIN32)  //WIN32, quick
+    quick_widget_t quick_widgets[8+2],
+        *qc = quick_widgets;
+#else
     quick_widget_t quick_widgets[] = {
         /* *INDENT-OFF* */
         /* TRANSLATORS: no need to translate 'Confirmation', it's just a context prefix */
@@ -907,6 +1055,7 @@ confirm_box (void)
         QUICK_END
         /* *INDENT-ON* */
     };
+#endif  //WIN32
 
     quick_dialog_t qdlg = {
         -1, -1, 46,
@@ -914,6 +1063,20 @@ confirm_box (void)
         quick_widgets, NULL, NULL
     };
 
+#if defined(WIN32)  //WIN32, quick
+    qc = XQUICK_CHECKBOX (qc, Q_("Confirmation|&Delete"), &confirm_delete, NULL);
+    qc = XQUICK_CHECKBOX (qc, Q_("Confirmation|O&verwrite"), &confirm_overwrite, NULL);
+    qc = XQUICK_CHECKBOX (qc, Q_("Confirmation|&Execute"), &confirm_execute, NULL);
+    qc = XQUICK_CHECKBOX (qc, Q_("Confirmation|E&xit"), &confirm_exit, NULL);
+    qc = XQUICK_CHECKBOX (qc, Q_("Confirmation|Di&rectory hotlist delete"),
+                              &confirm_directory_hotlist_delete, NULL);
+    qc = XQUICK_CHECKBOX (qc, Q_("Confirmation|&History cleanup"),
+                              &mc_global.widget.confirm_history_cleanup, NULL);
+    qc = XQUICK_BUTTONS_OK_CANCEL (qc);
+    qc = XQUICK_END (qc);
+    assert(qc == (quick_widgets + (sizeof(quick_widgets)/sizeof(quick_widgets[0]))));
+#endif  //WIN32, quick
+
     (void) quick_dialog (&qdlg);
 }
 
@@ -933,6 +1096,10 @@ display_bits_box (void)
         N_("7 &bits")
     };
 
+#if defined(WIN32)  //WIN32, quick
+    quick_widget_t quick_widgets[5+2],
+        *qc = quick_widgets;
+#else
     quick_widget_t quick_widgets[] = {
         /* *INDENT-OFF* */
         QUICK_RADIO (4, display_bits_str, &current_mode, NULL),
@@ -942,6 +1109,7 @@ display_bits_box (void)
         QUICK_END
         /* *INDENT-ON* */
     };
+#endif  //WIN32,quick
 
     quick_dialog_t qdlg = {
         -1, -1, 46,
@@ -949,6 +1117,15 @@ display_bits_box (void)
         quick_widgets, NULL, NULL
     };
 
+#if defined(WIN32)  //WIN32, quick
+    qc = XQUICK_RADIO (qc, 4, display_bits_str, &current_mode, NULL);
+    qc = XQUICK_SEPARATOR (qc, TRUE);
+    qc = XQUICK_CHECKBOX (qc, N_("F&ull 8 bits input"), &new_meta, NULL);
+    qc = XQUICK_BUTTONS_OK_CANCEL (qc);
+    qc = XQUICK_END (qc);
+    assert(qc == (quick_widgets + (sizeof(quick_widgets)/sizeof(quick_widgets[0]))));
+#endif  //WIN32, quick
+
     if (mc_global.full_eight_bits)
         current_mode = 0;
     else if (mc_global.eight_bit_clean)
@@ -987,6 +1164,10 @@ display_bits_box (void)
     {
         int new_meta;
 
+#if defined(WIN32)  //WIN32, quick
+        quick_widget_t quick_widgets[9+2],
+            *qc = quick_widgets;
+#else
         quick_widget_t quick_widgets[] = {
             /* *INDENT-OFF* */
             QUICK_START_COLUMNS,
@@ -1000,6 +1181,7 @@ display_bits_box (void)
             QUICK_END
             /* *INDENT-ON* */
         };
+#endif  //WIN32,quick
 
         quick_dialog_t qdlg = {
             -1, -1, 46,
@@ -1007,6 +1189,19 @@ display_bits_box (void)
             quick_widgets, NULL, NULL
         };
 
+#if defined(WIN32)  //WIN32, quick
+        qc = XQUICK_START_COLUMNS (qc);
+        qc =    XQUICK_LABEL (qc, N_("Input / display codepage:"), NULL),
+        qc = XQUICK_NEXT_COLUMN (qc);
+        qc =    XQUICK_BUTTON (qc, cpname, B_USER, sel_charset_button, NULL),
+        qc = XQUICK_STOP_COLUMNS (qc);
+        qc = XQUICK_SEPARATOR (qc, TRUE),
+        qc =    XQUICK_CHECKBOX (qc, N_("F&ull 8 bits input"), &new_meta, NULL),
+        qc = XQUICK_BUTTONS_OK_CANCEL (qc);
+        qc = XQUICK_END (qc);
+        assert(qc == (quick_widgets + (sizeof(quick_widgets)/sizeof(quick_widgets[0]))));
+#endif  //WIN32, quick
+
         new_meta = !use_8th_bit_as_meta;
         application_keypad_mode ();
 
@@ -1098,6 +1293,14 @@ configure_vfs (void)
         char *ret_directory_timeout;
 #endif /* ENABLE_VFS_FTP */
 
+#if defined(WIN32)  //WIN32, quick
+#ifdef ENABLE_VFS_FTP
+        quick_widget_t quick_widgets[11+2],
+#else
+        quick_widget_t quick_widgets[3+2],
+#endif
+            *qc = quick_widgets;
+#else
         quick_widget_t quick_widgets[] = {
             /* *INDENT-OFF* */
             QUICK_LABELED_INPUT (N_("Timeout for freeing VFSs (sec):"), input_label_left,
@@ -1124,6 +1327,7 @@ configure_vfs (void)
             QUICK_END
             /* *INDENT-ON* */
         };
+#endif  //WIN32, quick
 
         quick_dialog_t qdlg = {
             -1, -1, 56,
@@ -1134,9 +1338,39 @@ configure_vfs (void)
 #else
             NULL,
 #endif
-            NULL,
+            NULL
         };
 
+#if defined(WIN32)  //WIN32, quick
+        qc = XQUICK_LABELED_INPUT (qc,
+                                N_("Timeout for freeing VFSs (sec):"), input_label_left,
+                                buffer2, "input-timo-vfs", &ret_timeout, NULL, FALSE, FALSE,
+                                INPUT_COMPLETE_NONE);
+#ifdef ENABLE_VFS_FTP
+        qc = XQUICK_SEPARATOR (qc, TRUE);
+        qc = XQUICK_LABELED_INPUT (qc,
+                                N_("FTP anonymous password:"), input_label_left,
+                                ftpfs_anonymous_passwd, "input-passwd", &ret_passwd, NULL,
+                                FALSE, FALSE, INPUT_COMPLETE_NONE);
+        qc = XQUICK_LABELED_INPUT (qc,
+                                N_("FTP directory cache timeout (sec):"), input_label_left,
+                                buffer3, "input-timeout", &ret_directory_timeout, NULL,
+                                FALSE, FALSE, INPUT_COMPLETE_NONE);
+        qc = XQUICK_CHECKBOX (qc, N_("&Always use ftp proxy:"), &ftpfs_always_use_proxy,
+                                    &ftpfs_always_use_proxy_id);
+        qc = XQUICK_INPUT (qc,
+                            ftpfs_proxy_host, "input-ftp-proxy", &ret_ftp_proxy,
+                            &ftpfs_proxy_host_id, FALSE, FALSE, INPUT_COMPLETE_HOSTNAMES);
+        qc = XQUICK_CHECKBOX (qc, N_("&Use ~/.netrc"), &ftpfs_use_netrc, NULL);
+        qc = XQUICK_CHECKBOX (qc, N_("Use &passive mode"), &ftpfs_use_passive_connections, NULL);
+        qc = XQUICK_CHECKBOX (qc, N_("Use passive mode over pro&xy"),
+                                    &ftpfs_use_passive_connections_over_proxy, NULL);
+#endif /* ENABLE_VFS_FTP */
+        qc = XQUICK_BUTTONS_OK_CANCEL (qc);
+        qc = XQUICK_END (qc);
+        assert(qc == (quick_widgets + (sizeof(quick_widgets)/sizeof(quick_widgets[0]))));
+#endif  //WIN32, quick
+
 #ifdef ENABLE_VFS_FTP
         if (!ftpfs_always_use_proxy)
             quick_widgets[5].options = W_DISABLED;
@@ -1175,11 +1409,16 @@ cd_dialog (void)
     const Widget *w = WIDGET (current_panel);
     char *my_str;
 
+#if defined(WIN32)  //WIN32, quick
+    quick_widget_t quick_widgets[2],
+            *qc = quick_widgets;
+#else
     quick_widget_t quick_widgets[] = {
         QUICK_LABELED_INPUT (N_("cd"), input_label_left, "", "input", &my_str, NULL, FALSE, TRUE,
                              INPUT_COMPLETE_FILENAMES | INPUT_COMPLETE_CD),
         QUICK_END
     };
+#endif  //WIN32, quick
 
     quick_dialog_t qdlg = {
         w->y + w->lines - 6, w->x, w->cols,
@@ -1187,6 +1426,14 @@ cd_dialog (void)
         quick_widgets, NULL, NULL
     };
 
+#if defined(WIN32)  //WIN32, quick
+    qc = XQUICK_LABELED_INPUT (qc,
+							N_("cd"), input_label_left, "", "input", &my_str, NULL, FALSE, TRUE,
+                          	INPUT_COMPLETE_FILENAMES | INPUT_COMPLETE_CD);
+    qc = XQUICK_END (qc);
+    assert(qc == (quick_widgets + (sizeof(quick_widgets)/sizeof(quick_widgets[0]))));
+#endif  //WIN32, quick
+
     return (quick_dialog (&qdlg) != B_CANCEL) ? my_str : NULL;
 }
 
@@ -1196,6 +1443,10 @@ void
 symlink_dialog (const vfs_path_t * existing_vpath, const vfs_path_t * new_vpath,
                 char **ret_existing, char **ret_new)
 {
+#if defined(WIN32)  //WIN32, quick
+    quick_widget_t quick_widgets[5+2],
+                *qc = quick_widgets;
+#else
     quick_widget_t quick_widgets[] = {
         /* *INDENT-OFF* */
         QUICK_LABELED_INPUT (N_("Existing filename (filename symlink will point to):"),
@@ -1209,13 +1460,29 @@ symlink_dialog (const vfs_path_t * existing_vpath, const vfs_path_t * new_vpath,
         QUICK_END
         /* *INDENT-ON* */
     };
+#endif  //WIN32, quick
 
-    quick_dialog_t qdlg = {
+   quick_dialog_t qdlg = {
         -1, -1, 64,
         N_("Symbolic link"), "[File Menu]",
         quick_widgets, NULL, NULL
     };
 
+#if defined(WIN32)  //WIN32, quick
+        qc = XQUICK_LABELED_INPUT (qc,
+                            N_("Existing filename (filename symlink will point to):"),
+                            input_label_above, vfs_path_as_str (existing_vpath), "input-2",
+                            ret_existing, NULL, FALSE, FALSE, INPUT_COMPLETE_FILENAMES);
+        qc = XQUICK_SEPARATOR (qc, FALSE);
+        qc = XQUICK_LABELED_INPUT (qc,
+                            N_("Symbolic link filename:"), input_label_above,
+                            vfs_path_as_str (new_vpath), "input-1",
+                            ret_new, NULL, FALSE, FALSE, INPUT_COMPLETE_FILENAMES);
+        qc = XQUICK_BUTTONS_OK_CANCEL (qc);
+        qc = XQUICK_END (qc);
+        assert(qc == (quick_widgets + (sizeof(quick_widgets)/sizeof(quick_widgets[0]))));
+#endif  //WIN32, quick
+
     if (quick_dialog (&qdlg) == B_CANCEL)
     {
         *ret_new = NULL;
diff --git a/src/filemanager/boxes.c.BACKUP.c b/src/filemanager/boxes.c.BACKUP.c
new file mode 100644
index 0000000..7a84807
--- /dev/null
+++ b/src/filemanager/boxes.c.BACKUP.c
@@ -0,0 +1,1494 @@
+/*
+   Some misc dialog boxes for the program.
+
+   Copyright (C) 1994, 1995, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
+   2005, 2006, 2009, 2010, 2011, 2012, 2013
+   The Free Software Foundation, Inc.
+
+   Written by:
+   Miguel de Icaza, 1994, 1995
+   Jakub Jelinek, 1995
+   Andrew Borodin <aborodin@vmail.ru>, 2009, 2010, 2011, 2012, 2013
+
+   This file is part of the Midnight Commander.
+
+   The Midnight Commander is free software: you can redistribute it
+   and/or modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation, either version 3 of the License,
+   or (at your option) any later version.
+
+   The Midnight Commander is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** \file boxes.c
+ *  \brief Source: Some misc dialog boxes for the program
+ */
+
+#include <config.h>
+
+#include <ctype.h>
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+
+#include "lib/global.h"
+
+#include "lib/tty/tty.h"
+#include "lib/tty/key.h"        /* XCTRL and ALT macros  */
+#include "lib/skin.h"           /* INPUT_COLOR */
+#include "lib/mcconfig.h"       /* Load/save user formats */
+#include "lib/strutil.h"
+
+#include "lib/vfs/vfs.h"
+#ifdef ENABLE_VFS_FTP
+#include "src/vfs/ftpfs/ftpfs.h"
+#endif /* ENABLE_VFS_FTP */
+#ifdef ENABLE_VFS_SMB
+#include "src/vfs/smbfs/smbfs.h"
+#endif /* ENABLE_VFS_SMB */
+
+#include "lib/util.h"           /* Q_() */
+#include "lib/widget.h"
+
+#include "src/setup.h"
+#include "src/history.h"        /* MC_HISTORY_ESC_TIMEOUT */
+#include "src/execute.h"        /* pause_after_run */
+#ifdef ENABLE_BACKGROUND
+#include "src/background.h"     /* task_list */
+#endif
+
+#ifdef HAVE_CHARSET
+#include "lib/charsets.h"
+#include "src/selcodepage.h"
+#endif
+
+#include "command.h"            /* For cmdline */
+#include "dir.h"
+#include "panel.h"              /* LIST_TYPES */
+#include "tree.h"
+#include "layout.h"             /* for get_nth_panel_name proto */
+#include "midnight.h"           /* current_panel */
+
+#include "boxes.h"
+
+/*** global variables ****************************************************************************/
+
+/*** file scope macro definitions ****************************************************************/
+
+#ifdef ENABLE_BACKGROUND
+#define B_STOP   (B_USER+1)
+#define B_RESUME (B_USER+2)
+#define B_KILL   (B_USER+3)
+#endif /* ENABLE_BACKGROUND */
+
+/*** file scope type declarations ****************************************************************/
+
+/*** file scope variables ************************************************************************/
+
+unsigned long configure_old_esc_mode_id, configure_time_out_id;
+
+/* Index in list_types[] for "user defined" */
+static const int panel_listing_user_idx = 3;
+
+static char **status_format;
+static int listing_user_hotkey = 'u';
+static unsigned long panel_listing_types_id, panel_user_format_id;
+static unsigned long mini_user_status_id, mini_user_format_id;
+
+#ifdef HAVE_CHARSET
+static int new_display_codepage;
+static unsigned long disp_bits_name_id;
+#endif /* HAVE_CHARSET */
+
+#if defined(ENABLE_VFS) && defined(ENABLE_VFS_FTP)
+static unsigned long ftpfs_always_use_proxy_id, ftpfs_proxy_host_id;
+#endif /* ENABLE_VFS && ENABLE_VFS_FTP */
+
+#ifdef ENABLE_BACKGROUND
+static WListbox *bg_list = NULL;
+#endif /* ENABLE_BACKGROUND */
+
+/* --------------------------------------------------------------------------------------------- */
+/*** file scope functions ************************************************************************/
+/* --------------------------------------------------------------------------------------------- */
+
+static cb_ret_t
+configure_callback (Widget * w, Widget * sender, widget_msg_t msg, int parm, void *data)
+{
+    switch (msg)
+    {
+    case MSG_ACTION:
+        /* message from "Single press" checkbutton */
+        if (sender != NULL && sender->id == configure_old_esc_mode_id)
+        {
+            const gboolean not_single = !(CHECK (sender)->state & C_BOOL);
+            Widget *ww;
+
+            /* input line */
+            ww = dlg_find_by_id (DIALOG (w), configure_time_out_id);
+            widget_disable (ww, not_single);
+
+            return MSG_HANDLED;
+        }
+        return MSG_NOT_HANDLED;
+
+    default:
+        return dlg_default_callback (w, sender, msg, parm, data);
+    }
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+static cb_ret_t
+panel_listing_callback (Widget * w, Widget * sender, widget_msg_t msg, int parm, void *data)
+{
+    WDialog *h = DIALOG (w);
+
+    switch (msg)
+    {
+    case MSG_KEY:
+        if (parm == '\n')
+        {
+            Widget *wi;
+
+            wi = dlg_find_by_id (h, panel_listing_types_id);
+            if (widget_is_active (wi))
+            {
+                WInput *in;
+
+                in = INPUT (dlg_find_by_id (h, mini_user_format_id));
+                input_assign_text (in, status_format[RADIO (wi)->sel]);
+                dlg_stop (h);
+                return MSG_HANDLED;
+            }
+
+            wi = dlg_find_by_id (h, panel_user_format_id);
+            if (widget_is_active (wi))
+            {
+                h->ret_value = B_USER + 6;
+                dlg_stop (h);
+                return MSG_HANDLED;
+            }
+
+            wi = dlg_find_by_id (h, mini_user_format_id);
+            if (widget_is_active (wi))
+            {
+                h->ret_value = B_USER + 7;
+                dlg_stop (h);
+                return MSG_HANDLED;
+            }
+        }
+
+        if (g_ascii_tolower (parm) == listing_user_hotkey)
+        {
+            Widget *wi;
+
+            wi = dlg_find_by_id (h, panel_user_format_id);
+            if (widget_is_active (wi))
+            {
+                wi = dlg_find_by_id (h, mini_user_format_id);
+                if (widget_is_active (wi))
+                {
+                    WRadio *r;
+
+                    r = RADIO (dlg_find_by_id (h, panel_listing_types_id));
+                    r->pos = r->sel = panel_listing_user_idx;
+                    dlg_select_widget (WIDGET (r));     /* force redraw */
+                    send_message (h, r, MSG_ACTION, 0, NULL);
+                    return MSG_HANDLED;
+                }
+            }
+        }
+        return MSG_NOT_HANDLED;
+
+    case MSG_ACTION:
+        if (sender != NULL && sender->id == panel_listing_types_id)
+        {
+            WCheck *ch;
+            WInput *in1, *in2;
+
+            in1 = INPUT (dlg_find_by_id (h, panel_user_format_id));
+            ch = CHECK (dlg_find_by_id (h, mini_user_status_id));
+            in2 = INPUT (dlg_find_by_id (h, mini_user_format_id));
+
+            if (!(ch->state & C_BOOL))
+                input_assign_text (in2, status_format[RADIO (sender)->sel]);
+            input_update (in2, FALSE);
+            input_update (in1, FALSE);
+            widget_disable (WIDGET (in1), RADIO (sender)->sel != panel_listing_user_idx);
+            return MSG_HANDLED;
+        }
+
+        if (sender != NULL && sender->id == mini_user_status_id)
+        {
+            WInput *in;
+
+            in = INPUT (dlg_find_by_id (h, mini_user_format_id));
+
+            if (CHECK (sender)->state & C_BOOL)
+            {
+                widget_disable (WIDGET (in), FALSE);
+                input_assign_text (in, status_format[3]);
+            }
+            else
+            {
+                WRadio *r;
+
+                r = RADIO (dlg_find_by_id (h, panel_listing_types_id));
+                widget_disable (WIDGET (in), TRUE);
+                input_assign_text (in, status_format[r->sel]);
+            }
+            /* input_update (in, FALSE); */
+            return MSG_HANDLED;
+        }
+
+        return MSG_NOT_HANDLED;
+
+    default:
+        return dlg_default_callback (w, sender, msg, parm, data);
+    }
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+#ifdef HAVE_CHARSET
+static int
+sel_charset_button (WButton * button, int action)
+{
+    int new_dcp;
+
+    (void) action;
+
+    new_dcp = select_charset (-1, -1, new_display_codepage, TRUE);
+
+    if (new_dcp != SELECT_CHARSET_CANCEL)
+    {
+        const char *cpname;
+        char buf[BUF_TINY];
+        Widget *w;
+
+        new_display_codepage = new_dcp;
+        cpname = (new_display_codepage == SELECT_CHARSET_OTHER_8BIT) ?
+            _("Other 8 bit") :
+            ((codepage_desc *) g_ptr_array_index (codepages, new_display_codepage))->name;
+        if (cpname != NULL)
+            mc_global.utf8_display = str_isutf8 (cpname);
+        /* avoid strange bug with label repainting */
+        g_snprintf (buf, sizeof (buf), "%-27s", cpname);
+        w = dlg_find_by_id (WIDGET (button)->owner, disp_bits_name_id);
+        label_set_text (LABEL (w), buf);
+    }
+
+    return 0;
+}
+#endif /* HAVE_CHARSET */
+
+/* --------------------------------------------------------------------------------------------- */
+
+static cb_ret_t
+tree_callback (Widget * w, Widget * sender, widget_msg_t msg, int parm, void *data)
+{
+    WDialog *h = DIALOG (w);
+
+    switch (msg)
+    {
+    case MSG_RESIZE:
+        {
+            Widget *bar;
+
+            /* simply call dlg_set_size() with new size */
+            dlg_set_size (h, LINES - 9, COLS - 20);
+            bar = WIDGET (find_buttonbar (h));
+            bar->x = 0;
+            bar->y = LINES - 1;
+            return MSG_HANDLED;
+        }
+
+    case MSG_ACTION:
+        return send_message (find_tree (h), NULL, MSG_ACTION, parm, NULL);
+
+    default:
+        return dlg_default_callback (w, sender, msg, parm, data);
+    }
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+#if defined(ENABLE_VFS) && defined (ENABLE_VFS_FTP)
+static cb_ret_t
+confvfs_callback (Widget * w, Widget * sender, widget_msg_t msg, int parm, void *data)
+{
+    switch (msg)
+    {
+    case MSG_ACTION:
+        /* message from "Always use ftp proxy" checkbutton */
+        if (sender != NULL && sender->id == ftpfs_always_use_proxy_id)
+        {
+            const gboolean not_use = !(CHECK (sender)->state & C_BOOL);
+            Widget *wi;
+
+            /* input */
+            wi = dlg_find_by_id (DIALOG (w), ftpfs_proxy_host_id);
+            widget_disable (wi, not_use);
+            return MSG_HANDLED;
+        }
+        return MSG_NOT_HANDLED;
+
+    default:
+        return dlg_default_callback (w, sender, msg, parm, data);
+    }
+}
+#endif /* ENABLE_VFS && ENABLE_VFS_FTP */
+
+/* --------------------------------------------------------------------------------------------- */
+
+#ifdef ENABLE_BACKGROUND
+static void
+jobs_fill_listbox (WListbox * list)
+{
+    static const char *state_str[2] = { "", "" };
+    TaskList *tl;
+
+    if (state_str[0] == '\0')
+    {
+        state_str[0] = _("Running");
+        state_str[1] = _("Stopped");
+    }
+
+    for (tl = task_list; tl != NULL; tl = tl->next)
+    {
+        char *s;
+
+        s = g_strconcat (state_str[tl->state], " ", tl->info, (char *) NULL);
+        listbox_add_item (list, LISTBOX_APPEND_AT_END, 0, s, (void *) tl);
+        g_free (s);
+    }
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+static int
+task_cb (WButton * button, int action)
+{
+    TaskList *tl;
+    int sig = 0;
+
+    (void) button;
+
+    if (bg_list->list == NULL)
+        return 0;
+
+    /* Get this instance information */
+    listbox_get_current (bg_list, NULL, (void **) &tl);
+
+#ifdef SIGTSTP
+    if (action == B_STOP)
+    {
+        sig = SIGSTOP;
+        tl->state = Task_Stopped;
+    }
+    else if (action == B_RESUME)
+    {
+        sig = SIGCONT;
+        tl->state = Task_Running;
+    }
+    else
+#endif
+    if (action == B_KILL)
+        sig = SIGKILL;
+
+    if (sig == SIGKILL)
+        unregister_task_running (tl->pid, tl->fd);
+
+    kill (tl->pid, sig);
+    listbox_remove_list (bg_list);
+    jobs_fill_listbox (bg_list);
+
+    /* This can be optimized to just redraw this widget :-) */
+    dlg_redraw (WIDGET (button)->owner);
+
+    return 0;
+}
+#endif /* ENABLE_BACKGROUND */
+
+/* --------------------------------------------------------------------------------------------- */
+/*** public functions ****************************************************************************/
+/* --------------------------------------------------------------------------------------------- */
+
+void
+configure_box (void)
+{
+    const char *pause_options[] = {
+        N_("&Never"),
+        N_("On dum&b terminals"),
+        N_("Alwa&ys")
+    };
+
+    int pause_options_num;
+
+    pause_options_num = G_N_ELEMENTS (pause_options);
+
+    {
+        char time_out[BUF_TINY] = "";
+        char *time_out_new;
+
+#if defined(WIN32)  //WIN32, quick
+        quick_widget_t quick_widgets[35+2],
+            *qc = quick_widgets;
+#else
+        quick_widget_t quick_widgets[] = {
+            /* *INDENT-OFF* */
+            QUICK_START_COLUMNS,
+                QUICK_START_GROUPBOX (N_("File operations")),
+                    QUICK_CHECKBOX (N_("&Verbose operation"), &verbose, NULL),
+                    QUICK_CHECKBOX (N_("Compute tota&ls"), &file_op_compute_totals, NULL),
+                    QUICK_CHECKBOX (N_("Classic pro&gressbar"), &classic_progressbar, NULL),
+                    QUICK_CHECKBOX (N_("Mkdi&r autoname"), &auto_fill_mkdir_name, NULL),
+                    QUICK_CHECKBOX (N_("&Preallocate space"), &mc_global.vfs.preallocate_space,
+                                    NULL),
+                QUICK_STOP_GROUPBOX,
+                QUICK_START_GROUPBOX (N_("Esc key mode")),
+                    QUICK_CHECKBOX (N_("S&ingle press"), &old_esc_mode, &configure_old_esc_mode_id),
+                    QUICK_LABELED_INPUT (N_("Timeout:"), input_label_left,
+                                         (const char *) time_out, MC_HISTORY_ESC_TIMEOUT,
+                                         &time_out_new, &configure_time_out_id, FALSE, FALSE,
+                                         INPUT_COMPLETE_NONE),
+                QUICK_STOP_GROUPBOX,
+                QUICK_START_GROUPBOX (N_("Pause after run")),
+                    QUICK_RADIO (pause_options_num, pause_options, &pause_after_run, NULL),
+                QUICK_STOP_GROUPBOX,
+            QUICK_NEXT_COLUMN,
+                QUICK_START_GROUPBOX (N_("Other options")),
+                    QUICK_CHECKBOX (N_("Use internal edi&t"), &use_internal_edit, NULL),
+                    QUICK_CHECKBOX (N_("Use internal vie&w"), &use_internal_view, NULL),
+                    QUICK_CHECKBOX (N_("A&sk new file name"),
+                                    &editor_ask_filename_before_edit, NULL),
+                    QUICK_CHECKBOX (N_("Auto m&enus"), &auto_menu, NULL),
+                    QUICK_CHECKBOX (N_("&Drop down menus"), &drop_menus, NULL),
+                    QUICK_CHECKBOX (N_("S&hell patterns"), &easy_patterns, NULL),
+                    QUICK_CHECKBOX (N_("Co&mplete: show all"),
+                                    &mc_global.widget.show_all_if_ambiguous, NULL),
+                    QUICK_CHECKBOX (N_("Rotating d&ash"), &nice_rotating_dash, NULL),
+                    QUICK_CHECKBOX (N_("Cd follows lin&ks"), &mc_global.vfs.cd_symlinks, NULL),
+                    QUICK_CHECKBOX (N_("Sa&fe delete"), &safe_delete, NULL),
+                    QUICK_CHECKBOX (N_("A&uto save setup"), &auto_save_setup, NULL),
+                    QUICK_SEPARATOR (FALSE),
+                    QUICK_SEPARATOR (FALSE),
+                    QUICK_SEPARATOR (FALSE),
+                QUICK_STOP_GROUPBOX,
+            QUICK_STOP_COLUMNS,
+            QUICK_BUTTONS_OK_CANCEL,
+            QUICK_END
+            /* *INDENT-ON* */
+        };
+#endif  //WIN32
+
+        quick_dialog_t qdlg = {
+            -1, -1, 60,
+            N_("Configure options"), "[Configuration]",
+            quick_widgets, configure_callback, NULL
+        };
+
+#if defined(WIN32)  //WIN32, quick
+        qc = XQUICK_START_COLUMNS (qc);
+        qc =     XQUICK_START_GROUPBOX (qc, N_("File operations"));
+        qc =         XQUICK_CHECKBOX (qc, N_("&Verbose operation"), &verbose, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("Compute tota&ls"), &file_op_compute_totals, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("Classic pro&gressbar"), &classic_progressbar, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("Mkdi&r autoname"), &auto_fill_mkdir_name, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("Preallocate &space"), &mc_global.vfs.preallocate_space, NULL);
+        qc =     XQUICK_STOP_GROUPBOX (qc);
+        qc =     XQUICK_START_GROUPBOX (qc, N_("Esc key mode"));
+        qc =         XQUICK_CHECKBOX (qc, N_("S&ingle press"), &old_esc_mode, &configure_old_esc_mode_id);
+        qc =         XQUICK_LABELED_INPUT (qc, N_("Timeout:"), input_label_left,
+                                           (const char *) time_out, 0, MC_HISTORY_ESC_TIMEOUT,
+                                           &time_out_new, &configure_time_out_id);
+        qc =     XQUICK_STOP_GROUPBOX (qc);
+        qc =     XQUICK_START_GROUPBOX (qc, N_("Pause after run"));
+        qc =         XQUICK_RADIO (qc, pause_options_num, pause_options, &pause_after_run, NULL);
+        qc =     XQUICK_STOP_GROUPBOX (qc);
+        qc = XQUICK_NEXT_COLUMN (qc);
+        qc =     XQUICK_START_GROUPBOX (qc, N_("Other options"));
+        qc =         XQUICK_CHECKBOX (qc, N_("Use internal edi&t"), &use_internal_edit, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("Use internal vie&w"), &use_internal_view, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("Auto m&enus"), &auto_menu, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("&Drop down menus"), &drop_menus, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("Shell &patterns"), &easy_patterns, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("Co&mplete: show all"), &mc_global.widget.show_all_if_ambiguous, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("Rotating d&ash"), &nice_rotating_dash, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("Cd follows lin&ks"), &mc_global.vfs.cd_symlinks, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("Sa&fe delete"), &safe_delete, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("A&uto save setup"), &auto_save_setup, NULL);
+        qc =         XQUICK_SEPARATOR (qc, FALSE);
+        qc =         XQUICK_SEPARATOR (qc, FALSE);
+        qc =         XQUICK_SEPARATOR (qc, FALSE);
+        qc =         XQUICK_SEPARATOR (qc, FALSE);
+        qc =     XQUICK_STOP_GROUPBOX (qc);
+        qc = XQUICK_STOP_COLUMNS (qc);
+        qc = XQUICK_BUTTONS_OK_CANCEL (qc);
+        qc = XQUICK_END (qc);
+        assert(qc == (quick_widgets + (sizeof(quick_widgets)/sizeof(quick_widgets[0]))));
+#endif
+
+        g_snprintf (time_out, sizeof (time_out), "%d", old_esc_mode_timeout);
+
+#ifndef USE_INTERNAL_EDIT
+        quick_widgets[17].options = W_DISABLED;
+#endif
+
+        if (!old_esc_mode)
+            quick_widgets[10].options = quick_widgets[11].options = W_DISABLED;
+
+#ifndef HAVE_POSIX_FALLOCATE
+        mc_global.vfs.preallocate_space = FALSE;
+        quick_widgets[7].options = W_DISABLED;
+#endif
+
+        if (quick_dialog (&qdlg) == B_ENTER)
+            old_esc_mode_timeout = atoi (time_out_new);
+
+        g_free (time_out_new);
+    }
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+void
+panel_options_box (void)
+{
+    int simple_swap;
+
+    simple_swap = mc_config_get_bool (mc_main_config, CONFIG_PANELS_SECTION,
+                                      "simple_swap", FALSE) ? 1 : 0;
+    {
+<<<<<<< HEAD
+#if defined(WIN32)  //WIN32, quick
+        quick_widget_t quick_widgets[31+2],
+            *qc = quick_widgets;
+#else
+=======
+        const char *qsearch_options[] = {
+            N_("Case &insensitive"),
+            N_("Cas&e sensitive"),
+            N_("Use panel sort mo&de")
+        };
+
+>>>>>>> 4.8.11
+        quick_widget_t quick_widgets[] = {
+            /* *INDENT-OFF* */
+            QUICK_START_COLUMNS,
+                QUICK_START_GROUPBOX (N_("Main options")),
+                    QUICK_CHECKBOX (N_("Show mi&ni-status"), &panels_options.show_mini_info, NULL),
+                    QUICK_CHECKBOX (N_("Use SI si&ze units"), &panels_options.kilobyte_si, NULL),
+                    QUICK_CHECKBOX (N_("Mi&x all files"), &panels_options.mix_all_files, NULL),
+                    QUICK_CHECKBOX (N_("Show &backup files"), &panels_options.show_backups, NULL),
+                    QUICK_CHECKBOX (N_("Show &hidden files"), &panels_options.show_dot_files, NULL),
+                    QUICK_CHECKBOX (N_("&Fast dir reload"), &panels_options.fast_reload, NULL),
+                    QUICK_CHECKBOX (N_("Ma&rk moves down"), &panels_options.mark_moves_down, NULL),
+                    QUICK_CHECKBOX (N_("Re&verse files only"), &panels_options.reverse_files_only,
+                                    NULL),
+                    QUICK_CHECKBOX (N_("Simple s&wap"), &simple_swap, NULL),
+                    QUICK_CHECKBOX (N_("A&uto save panels setup"), &panels_options.auto_save_setup,
+                                    NULL),
+                    QUICK_SEPARATOR (FALSE),
+                    QUICK_SEPARATOR (FALSE),
+                QUICK_STOP_GROUPBOX,
+            QUICK_NEXT_COLUMN,
+                QUICK_START_GROUPBOX (N_("Navigation")),
+                    QUICK_CHECKBOX (N_("L&ynx-like motion"), &panels_options.navigate_with_arrows,
+                                    NULL),
+                    QUICK_CHECKBOX (N_("Pa&ge scrolling"), &panels_options.scroll_pages, NULL),
+                    QUICK_CHECKBOX (N_("&Mouse page scrolling"), &panels_options.mouse_move_pages,
+                                    NULL),
+                QUICK_STOP_GROUPBOX,
+                QUICK_START_GROUPBOX (N_("File highlight")),
+                    QUICK_CHECKBOX (N_("File &types"), &panels_options.filetype_mode, NULL),
+                    QUICK_CHECKBOX (N_("&Permissions"), &panels_options.permission_mode, NULL),
+                QUICK_STOP_GROUPBOX,
+                QUICK_START_GROUPBOX (N_("Quick search")),
+                    QUICK_RADIO (QSEARCH_NUM, qsearch_options, (int *) &panels_options.qsearch_mode,
+                                 NULL),
+                QUICK_STOP_GROUPBOX,
+            QUICK_STOP_COLUMNS,
+            QUICK_BUTTONS_OK_CANCEL,
+            QUICK_END
+            /* *INDENT-ON* */
+        };
+#endif  //WIN32
+
+        quick_dialog_t qdlg = {
+            -1, -1, 60,
+            N_("Panel options"), "[Panel options]",
+            quick_widgets, NULL, NULL
+        };
+
+#if defined(WIN32)  //WIN32, quick
+        qc = XQUICK_START_COLUMNS (qc);
+        qc =     XQUICK_START_GROUPBOX (qc, N_("Main options"));
+        qc =         XQUICK_CHECKBOX (qc, N_("Show mi&ni-status"), &panels_options.show_mini_info, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("Use SI si&ze units"), &panels_options.kilobyte_si, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("Mi&x all files"), &panels_options.mix_all_files, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("Show &backup files"), &panels_options.show_backups, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("Show &hidden files"), &panels_options.show_dot_files, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("&Fast dir reload"), &panels_options.fast_reload, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("Ma&rk moves down"), &panels_options.mark_moves_down, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("Re&verse files only"), &panels_options.reverse_files_only, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("Simple s&wap"), &simple_swap, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("A&uto save panels setup"), &panels_options.auto_save_setup, NULL);
+        qc =         XQUICK_SEPARATOR (qc, FALSE);
+        qc =         XQUICK_SEPARATOR (qc, FALSE);
+        qc =     XQUICK_STOP_GROUPBOX (qc);
+        qc = XQUICK_NEXT_COLUMN (qc);
+        qc =     XQUICK_START_GROUPBOX (qc, N_("Navigation"));
+        qc =         XQUICK_CHECKBOX (qc, N_("L&ynx-like motion"), &panels_options.navigate_with_arrows, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("Pa&ge scrolling"), &panels_options.scroll_pages, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("&Mouse page scrolling"), &panels_options.mouse_move_pages, NULL);
+        qc =     XQUICK_STOP_GROUPBOX (qc);
+        qc =     XQUICK_START_GROUPBOX (qc, N_("File highlight"));
+        qc =         XQUICK_CHECKBOX (qc, N_("File &types"), &panels_options.filetype_mode, NULL);
+        qc =         XQUICK_CHECKBOX (qc, N_("&Permissions"), &panels_options.permission_mode, NULL);
+        qc =     XQUICK_STOP_GROUPBOX (qc);
+        qc =     XQUICK_START_GROUPBOX (qc, N_("Quick search"));
+        qc =         XQUICK_RADIO (qc, QSEARCH_NUM, qsearch_options, (int *) &panels_options.qsearch_mode, NULL);
+        qc =     XQUICK_STOP_GROUPBOX (qc);
+        qc = XQUICK_STOP_COLUMNS (qc);
+        qc = XQUICK_BUTTONS_OK_CANCEL (qc);
+        qc = XQUICK_END (qc);
+        assert(qc == (quick_widgets + (sizeof(quick_widgets)/sizeof(quick_widgets[0]))));
+#endif  //WIN32
+
+        if (quick_dialog (&qdlg) != B_ENTER)
+            return;
+    }
+
+    mc_config_set_bool (mc_main_config, CONFIG_PANELS_SECTION,
+                        "simple_swap", (gboolean) (simple_swap & C_BOOL));
+
+    if (!panels_options.fast_reload_msg_shown && panels_options.fast_reload)
+    {
+        message (D_NORMAL, _("Information"),
+                 _("Using the fast reload option may not reflect the exact\n"
+                   "directory contents. In this case you'll need to do a\n"
+                   "manual reload of the directory. See the man page for\n" "the details."));
+        panels_options.fast_reload_msg_shown = TRUE;
+    }
+
+    update_panels (UP_RELOAD, UP_KEEPSEL);
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+/* return list type */
+int
+panel_listing_box (WPanel * panel, char **userp, char **minip, int *use_msformat, int num)
+{
+    int result = -1;
+    char *section = NULL;
+
+    if (panel == NULL)
+    {
+        const char *p;
+        size_t i;
+
+        p = get_nth_panel_name (num);
+        panel = g_new (WPanel, 1);
+        panel->list_type = list_full;
+        panel->user_format = g_strdup (DEFAULT_USER_FORMAT);
+        panel->user_mini_status = 0;
+        for (i = 0; i < LIST_TYPES; i++)
+            panel->user_status_format[i] = g_strdup (DEFAULT_USER_FORMAT);
+        section = g_strconcat ("Temporal:", p, (char *) NULL);
+        if (!mc_config_has_group (mc_main_config, section))
+        {
+            g_free (section);
+            section = g_strdup (p);
+        }
+        panel_load_setup (panel, section);
+        g_free (section);
+    }
+
+    {
+        int mini_user_status;
+        char *panel_user_format = NULL;
+        char *mini_user_format = NULL;
+        const char *cp;
+
+        /* Controls whether the array strings have been translated */
+        const char *list_types[LIST_TYPES] = {
+            N_("&Full file list"),
+            N_("&Brief file list"),
+            N_("&Long file list"),
+            N_("&User defined:")
+        };
+
+#if defined(WIN32)  //WIN32, quick
+        quick_widget_t quick_widgets[7+2],
+            *qc = quick_widgets;
+#else
+        quick_widget_t quick_widgets[] = {
+            /* *INDENT-OFF* */
+            QUICK_RADIO (LIST_TYPES, list_types, &result, &panel_listing_types_id),
+            QUICK_INPUT (panel->user_format, "user-fmt-input", &panel_user_format,
+                         &panel_user_format_id, FALSE, FALSE, INPUT_COMPLETE_NONE),
+            QUICK_SEPARATOR (TRUE),
+            QUICK_CHECKBOX (N_("User &mini status"), &mini_user_status, &mini_user_status_id),
+            QUICK_INPUT (panel->user_status_format[panel->list_type], "mini_input",
+                         &mini_user_format, &mini_user_format_id, FALSE, FALSE, INPUT_COMPLETE_NONE),
+            QUICK_BUTTONS_OK_CANCEL,
+            QUICK_END
+            /* *INDENT-ON* */
+        };
+#endif  //WIN32, quick
+
+        quick_dialog_t qdlg = {
+            -1, -1, 48,
+            N_("Listing mode"), "[Listing Mode...]",
+            quick_widgets, panel_listing_callback, NULL
+        };
+
+#if defined(WIN32)  //WIN32, quick
+        qc = XQUICK_RADIO (qc, LIST_TYPES, list_types, &result, &panel_listing_types_id);
+        qc = XQUICK_INPUT (qc, panel->user_format, INPUT_COMPLETE_DEFAULT, "user-fmt-input",
+                                &panel_user_format, &panel_user_format_id);
+        qc = XQUICK_SEPARATOR (qc, TRUE);
+        qc = XQUICK_CHECKBOX (qc, N_("User &mini status"), &mini_user_status, &mini_user_status_id);
+        qc = XQUICK_INPUT (qc, panel->user_status_format[panel->list_type], INPUT_COMPLETE_DEFAULT,
+                            "mini_input", &mini_user_format, &mini_user_format_id);
+        qc = XQUICK_BUTTONS_OK_CANCEL (qc);
+        qc = XQUICK_END (qc);
+        assert(qc == (quick_widgets + (sizeof(quick_widgets)/sizeof(quick_widgets[0]))));
+#endif  //WIN32, quick
+
+        /* get hotkey of user-defined format string */
+        cp = strchr (_(list_types[panel_listing_user_idx]), '&');
+        if (cp != NULL && *++cp != '\0')
+            listing_user_hotkey = g_ascii_tolower (*cp);
+
+        mini_user_status = panel->user_mini_status;
+        result = panel->list_type;
+        status_format = panel->user_status_format;
+
+        if (panel->list_type != panel_listing_user_idx)
+            quick_widgets[1].options = W_DISABLED;
+
+        if (!mini_user_status)
+            quick_widgets[4].options = W_DISABLED;
+
+        if (quick_dialog (&qdlg) == B_CANCEL)
+            result = -1;
+        else
+        {
+            *userp = panel_user_format;
+            *minip = mini_user_format;
+            *use_msformat = mini_user_status;
+        }
+    }
+
+    if (section != NULL)
+    {
+        int i;
+
+        g_free (panel->user_format);
+        for (i = 0; i < LIST_TYPES; i++)
+            g_free (panel->user_status_format[i]);
+        g_free (panel);
+    }
+
+    return result;
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+const panel_field_t *
+sort_box (dir_sort_options_t * op, const panel_field_t * sort_field)
+{
+    const char **sort_orders_names;
+    gsize sort_names_num, i;
+    int sort_idx = 0;
+    const panel_field_t *result = NULL;
+
+    sort_orders_names = panel_get_sortable_fields (&sort_names_num);
+
+    for (i = 0; i < sort_names_num; i++)
+        if (strcmp (sort_orders_names[i], _(sort_field->title_hotkey)) == 0)
+        {
+            sort_idx = i;
+            break;
+        }
+
+    {
+#if defined(WIN32)  //WIN32, quick
+        quick_widget_t quick_widgets[9+2],
+            *qc = quick_widgets;
+#else
+        quick_widget_t quick_widgets[] = {
+            /* *INDENT-OFF* */
+            QUICK_START_COLUMNS,
+                QUICK_RADIO (sort_names_num, sort_orders_names, &sort_idx, NULL),
+            QUICK_NEXT_COLUMN,
+                QUICK_CHECKBOX (N_("Executable &first"), &op->exec_first, NULL),
+                QUICK_CHECKBOX (N_("Cas&e sensitive"), &op->case_sensitive, NULL),
+                QUICK_CHECKBOX (N_("&Reverse"), &op->reverse, NULL),
+            QUICK_STOP_COLUMNS,
+            QUICK_BUTTONS_OK_CANCEL,
+            QUICK_END
+            /* *INDENT-ON* */
+        };
+#endif  //WIN32, quick
+
+        quick_dialog_t qdlg = {
+            -1, -1, 40,
+            N_("Sort order"), "[Sort Order...]",
+            quick_widgets, NULL, NULL
+        };
+
+#if defined(WIN32)  //WIN32, quick
+        qc = XQUICK_START_COLUMNS (qc);
+        qc =    XQUICK_RADIO (qc, sort_names_num, sort_orders_names, &sort_idx, NULL);
+        qc = XQUICK_NEXT_COLUMN (qc);
+        qc =    XQUICK_CHECKBOX (qc, N_("Executable &first"), &info->exec_first, NULL);
+        qc =    XQUICK_CHECKBOX (qc, N_("Cas&e sensitive"), &info->case_sensitive, NULL);
+        qc =    XQUICK_CHECKBOX (qc, N_("&Reverse"), &info->reverse, NULL);
+        qc = XQUICK_STOP_COLUMNS (qc);
+        qc = XQUICK_BUTTONS_OK_CANCEL (qc);
+        qc = XQUICK_END(qc);
+        assert(qc == (quick_widgets + (sizeof(quick_widgets)/sizeof(quick_widgets[0]))));
+#endif  //WIN32, quick
+
+        if (quick_dialog (&qdlg) != B_CANCEL)
+            result = panel_get_field_by_title_hotkey (sort_orders_names[sort_idx]);
+
+        if (result == NULL)
+            result = sort_field;
+    }
+
+    g_strfreev ((gchar **) sort_orders_names);
+
+    return result;
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+void
+confirm_box (void)
+{
+#if defined(WIN32)  //WIN32, quick
+    quick_widget_t quick_widgets[8+2],
+        *qc = quick_widgets;
+#else
+    quick_widget_t quick_widgets[] = {
+        /* *INDENT-OFF* */
+        /* TRANSLATORS: no need to translate 'Confirmation', it's just a context prefix */
+        QUICK_CHECKBOX (Q_("Confirmation|&Delete"), &confirm_delete, NULL),
+        QUICK_CHECKBOX (Q_("Confirmation|O&verwrite"), &confirm_overwrite, NULL),
+        QUICK_CHECKBOX (Q_("Confirmation|&Execute"), &confirm_execute, NULL),
+        QUICK_CHECKBOX (Q_("Confirmation|E&xit"), &confirm_exit, NULL),
+        QUICK_CHECKBOX (Q_("Confirmation|Di&rectory hotlist delete"),
+                        &confirm_directory_hotlist_delete, NULL),
+        QUICK_CHECKBOX (Q_("Confirmation|&History cleanup"),
+                        &mc_global.widget.confirm_history_cleanup, NULL),
+        QUICK_BUTTONS_OK_CANCEL,
+        QUICK_END
+        /* *INDENT-ON* */
+    };
+#endif  //WIN32
+
+    quick_dialog_t qdlg = {
+        -1, -1, 46,
+        N_("Confirmation"), "[Confirmation]",
+        quick_widgets, NULL, NULL
+    };
+
+#if defined(WIN32)  //WIN32, quick
+    qc = XQUICK_CHECKBOX (qc, N_("Confirmation|&Delete"), &confirm_delete, NULL);
+    qc = XQUICK_CHECKBOX (qc, N_("Confirmation|O&verwrite"), &confirm_overwrite, NULL);
+    qc = XQUICK_CHECKBOX (qc, N_("Confirmation|&Execute"), &confirm_execute, NULL);
+    qc = XQUICK_CHECKBOX (qc, N_("Confirmation|E&xit"), &confirm_exit, NULL);
+    qc = XQUICK_CHECKBOX (qc, N_("Confirmation|Di&rectory hotlist delete"),
+                              &confirm_directory_hotlist_delete, NULL);
+    qc = XQUICK_CHECKBOX (qc, N_("Confirmation|&History cleanup"),
+                              &mc_global.widget.confirm_history_cleanup, NULL);
+    qc = XQUICK_BUTTONS_OK_CANCEL (qc);
+    qc = XQUICK_END (qc);
+    assert(qc == (quick_widgets + (sizeof(quick_widgets)/sizeof(quick_widgets[0]))));
+#endif  //WIN32, quick
+
+    (void) quick_dialog (&qdlg);
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+#ifndef HAVE_CHARSET
+void
+display_bits_box (void)
+{
+    int new_meta;
+    int current_mode;
+
+    const char *display_bits_str[] = {
+        N_("&UTF-8 output"),
+        N_("&Full 8 bits output"),
+        N_("&ISO 8859-1"),
+        N_("7 &bits")
+    };
+
+#if defined(WIN32)  //WIN32, quick
+    quick_widget_t quick_widgets[5+2],
+        *qc = quick_widgets;
+#else
+    quick_widget_t quick_widgets[] = {
+        /* *INDENT-OFF* */
+        QUICK_RADIO (4, display_bits_str, &current_mode, NULL),
+        QUICK_SEPARATOR (TRUE),
+        QUICK_CHECKBOX (N_("F&ull 8 bits input"), &new_meta, NULL),
+        QUICK_BUTTONS_OK_CANCEL,
+        QUICK_END
+        /* *INDENT-ON* */
+    };
+#endif  //WIN32,quick
+
+    quick_dialog_t qdlg = {
+        -1, -1, 46,
+        _("Display bits"), "[Display bits]",
+        quick_widgets, NULL, NULL
+    };
+
+#if defined(WIN32)  //WIN32, quick
+    qc = XQUICK_RADIO (qc, 4, display_bits_str, &current_mode, NULL);
+    qc = XQUICK_SEPARATOR (qc, TRUE);
+    qc = XQUICK_CHECKBOX (qc, N_("F&ull 8 bits input"), &new_meta, NULL);
+    qc = XQUICK_BUTTONS_OK_CANCEL (qc);
+    qc = XQUICK_END (qc);
+    assert(qc == (quick_widgets + (sizeof(quick_widgets)/sizeof(quick_widgets[0]))));
+#endif  //WIN32, quick
+
+    if (mc_global.full_eight_bits)
+        current_mode = 0;
+    else if (mc_global.eight_bit_clean)
+        current_mode = 1;
+    else
+        current_mode = 2;
+
+    new_meta = !use_8th_bit_as_meta;
+
+    if (quick_dialog (&qdlg) != B_CANCEL)
+    {
+        mc_global.eight_bit_clean = current_mode < 3;
+        mc_global.full_eight_bits = current_mode < 2;
+#ifndef HAVE_SLANG
+        meta (stdscr, mc_global.eight_bit_clean);
+#else
+        SLsmg_Display_Eight_Bit = mc_global.full_eight_bits ? 128 : 160;
+#endif
+        use_8th_bit_as_meta = !new_meta;
+    }
+}
+
+/* --------------------------------------------------------------------------------------------- */
+#else /* HAVE_CHARSET */
+
+void
+display_bits_box (void)
+{
+    const char *cpname;
+
+    cpname = (new_display_codepage < 0) ? _("Other 8 bit")
+        : ((codepage_desc *) g_ptr_array_index (codepages, new_display_codepage))->name;
+
+    new_display_codepage = mc_global.display_codepage;
+
+    {
+        int new_meta;
+
+#if defined(WIN32)  //WIN32, quick
+        quick_widget_t quick_widgets[13+2],
+            *qc = quick_widgets;
+#else
+        quick_widget_t quick_widgets[] = {
+            /* *INDENT-OFF* */
+            QUICK_START_COLUMNS,
+                QUICK_LABEL (N_("Input / display codepage:"), NULL),
+            QUICK_NEXT_COLUMN,
+            QUICK_STOP_COLUMNS,
+            QUICK_START_COLUMNS,
+                QUICK_LABEL (cpname, &disp_bits_name_id),
+            QUICK_NEXT_COLUMN,
+                QUICK_BUTTON (N_("&Select"), B_USER, sel_charset_button, NULL),
+            QUICK_STOP_COLUMNS,
+            QUICK_SEPARATOR (TRUE),
+                QUICK_CHECKBOX (N_("F&ull 8 bits input"), &new_meta, NULL),
+            QUICK_BUTTONS_OK_CANCEL,
+            QUICK_END
+            /* *INDENT-ON* */
+        };
+#endif  //WIN32,quick
+
+        quick_dialog_t qdlg = {
+            -1, -1, 46,
+            N_("Display bits"), "[Display bits]",
+            quick_widgets, NULL, NULL
+        };
+
+#if defined(WIN32)  //WIN32, quick
+        qc = XQUICK_START_COLUMNS (qc);
+        qc =      XQUICK_LABEL (qc, N_("Input / display codepage:"), NULL);
+        qc = XQUICK_NEXT_COLUMN (qc);
+        qc = XQUICK_STOP_COLUMNS (qc);
+        qc = XQUICK_START_COLUMNS (qc);
+        qc =      XQUICK_LABEL (qc, cpname, &disp_bits_name_id);
+        qc = XQUICK_NEXT_COLUMN (qc);
+        qc =      XQUICK_BUTTON (qc, N_("&Select"), B_USER, sel_charset_button, NULL);
+        qc = XQUICK_STOP_COLUMNS (qc);
+        qc = XQUICK_SEPARATOR (qc, TRUE);
+        qc =      XQUICK_CHECKBOX (qc, N_("F&ull 8 bits input"), &new_meta, NULL);
+        qc = XQUICK_BUTTONS_OK_CANCEL (qc);
+        qc = XQUICK_END (qc);
+        assert(qc == (quick_widgets + (sizeof(quick_widgets)/sizeof(quick_widgets[0]))));
+#endif  //WIN32, quick
+
+        new_meta = !use_8th_bit_as_meta;
+        application_keypad_mode ();
+
+        if (quick_dialog (&qdlg) == B_ENTER)
+        {
+            char *errmsg;
+
+            mc_global.display_codepage = new_display_codepage;
+
+            errmsg = init_translation_table (mc_global.source_codepage, mc_global.display_codepage);
+            if (errmsg != NULL)
+            {
+                message (D_ERROR, MSG_ERROR, "%s", errmsg);
+                g_free (errmsg);
+            }
+
+#ifdef HAVE_SLANG
+            tty_display_8bit (mc_global.display_codepage != 0 && mc_global.display_codepage != 1);
+#else
+            tty_display_8bit (mc_global.display_codepage != 0);
+#endif
+            use_8th_bit_as_meta = !new_meta;
+
+            repaint_screen ();
+        }
+    }
+}
+#endif /* HAVE_CHARSET */
+
+/* --------------------------------------------------------------------------------------------- */
+/** Show tree in a box, not on a panel */
+
+char *
+tree_box (const char *current_dir)
+{
+    WTree *mytree;
+    WDialog *dlg;
+    Widget *wd;
+    char *val = NULL;
+    WButtonBar *bar;
+
+    (void) current_dir;
+
+    /* Create the components */
+    dlg = dlg_create (TRUE, 0, 0, LINES - 9, COLS - 20, dialog_colors, tree_callback, NULL,
+                      "[Directory Tree]", _("Directory tree"), DLG_CENTER);
+    wd = WIDGET (dlg);
+
+    mytree = tree_new (2, 2, wd->lines - 6, wd->cols - 5, FALSE);
+    add_widget_autopos (dlg, mytree, WPOS_KEEP_ALL, NULL);
+    add_widget_autopos (dlg, hline_new (wd->lines - 4, 1, -1), WPOS_KEEP_BOTTOM, NULL);
+    bar = buttonbar_new (TRUE);
+    add_widget (dlg, bar);
+    /* restore ButtonBar coordinates after add_widget() */
+    WIDGET (bar)->x = 0;
+    WIDGET (bar)->y = LINES - 1;
+
+    if (dlg_run (dlg) == B_ENTER)
+    {
+        const vfs_path_t *selected_name;
+        selected_name = tree_selected_name (mytree);
+        val = g_strdup (vfs_path_as_str (selected_name));
+    }
+
+    dlg_destroy (dlg);
+    return val;
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+#ifdef ENABLE_VFS
+void
+configure_vfs (void)
+{
+    char buffer2[BUF_TINY];
+#ifdef ENABLE_VFS_FTP
+    char buffer3[BUF_TINY];
+
+    g_snprintf (buffer3, sizeof (buffer3), "%i", ftpfs_directory_timeout);
+#endif
+
+    g_snprintf (buffer2, sizeof (buffer2), "%i", vfs_timeout);
+
+    {
+        char *ret_timeout;
+#ifdef ENABLE_VFS_FTP
+        char *ret_passwd;
+        char *ret_ftp_proxy;
+        char *ret_directory_timeout;
+#endif /* ENABLE_VFS_FTP */
+
+#if defined(WIN32)  //WIN32, quick
+#ifdef ENABLE_VFS_FTP
+        quick_widget_t quick_widgets[11+2],
+#else
+        quick_widget_t quick_widgets[3+2],
+#endif
+            *qc = quick_widgets;
+#else
+        quick_widget_t quick_widgets[] = {
+            /* *INDENT-OFF* */
+            QUICK_LABELED_INPUT (N_("Timeout for freeing VFSs (sec):"), input_label_left,
+                                 buffer2, "input-timo-vfs", &ret_timeout, NULL, FALSE, FALSE,
+                                 INPUT_COMPLETE_NONE),
+#ifdef ENABLE_VFS_FTP
+            QUICK_SEPARATOR (TRUE),
+            QUICK_LABELED_INPUT (N_("FTP anonymous password:"), input_label_left,
+                                 ftpfs_anonymous_passwd, "input-passwd", &ret_passwd, NULL,
+                                 FALSE, FALSE, INPUT_COMPLETE_NONE),
+            QUICK_LABELED_INPUT (N_("FTP directory cache timeout (sec):"), input_label_left,
+                                 buffer3, "input-timeout", &ret_directory_timeout, NULL,
+                                 FALSE, FALSE, INPUT_COMPLETE_NONE),
+            QUICK_CHECKBOX (N_("&Always use ftp proxy:"), &ftpfs_always_use_proxy,
+                            &ftpfs_always_use_proxy_id),
+            QUICK_INPUT (ftpfs_proxy_host, "input-ftp-proxy", &ret_ftp_proxy,
+                         &ftpfs_proxy_host_id, FALSE, FALSE, INPUT_COMPLETE_HOSTNAMES),
+            QUICK_CHECKBOX (N_("&Use ~/.netrc"), &ftpfs_use_netrc, NULL),
+            QUICK_CHECKBOX (N_("Use &passive mode"), &ftpfs_use_passive_connections, NULL),
+            QUICK_CHECKBOX (N_("Use passive mode over pro&xy"),
+                            &ftpfs_use_passive_connections_over_proxy, NULL),
+#endif /* ENABLE_VFS_FTP */
+            QUICK_BUTTONS_OK_CANCEL,
+            QUICK_END
+            /* *INDENT-ON* */
+        };
+#endif  //WIN32, quick
+
+        quick_dialog_t qdlg = {
+            -1, -1, 56,
+            N_("Virtual File System Setting"), "[Virtual FS]",
+            quick_widgets,
+#ifdef ENABLE_VFS_FTP
+            confvfs_callback,
+#else
+            NULL,
+#endif
+            NULL
+        };
+
+#if defined(WIN32)  //WIN32, quick
+        qc = XQUICK_LABELED_INPUT (qc, N_("Timeout for freeing VFSs (sec):"), input_label_left,
+                                        buffer2, 0, "input-timo-vfs", &ret_timeout, NULL);
+#ifdef ENABLE_VFS_FTP
+        qc = XQUICK_SEPARATOR (qc, TRUE);
+        qc = XQUICK_LABELED_INPUT (qc, N_("FTP anonymous password:"), input_label_left,
+                                        ftpfs_anonymous_passwd, 0, "input-passwd", &ret_passwd, NULL);
+        qc = XQUICK_LABELED_INPUT (qc, N_("FTP directory cache timeout (sec):"), input_label_left,
+                                        buffer3, 0, "input-timeout", &ret_directory_timeout, NULL);
+        qc = XQUICK_CHECKBOX (qc, N_("&Always use ftp proxy:"), &ftpfs_always_use_proxy,
+                                    &ftpfs_always_use_proxy_id);
+        qc = XQUICK_INPUT (qc, ftpfs_proxy_host, 0, "input-ftp-proxy", &ret_ftp_proxy,
+                                &ftpfs_proxy_host_id);
+        qc = XQUICK_CHECKBOX (qc, N_("&Use ~/.netrc"), &ftpfs_use_netrc, NULL);
+        qc = XQUICK_CHECKBOX (qc, N_("Use &passive mode"), &ftpfs_use_passive_connections, NULL);
+        qc = XQUICK_CHECKBOX (qc, N_("Use passive mode over pro&xy"),
+                                    &ftpfs_use_passive_connections_over_proxy, NULL);
+#endif /* ENABLE_VFS_FTP */
+        qc = XQUICK_BUTTONS_OK_CANCEL (qc);
+        qc = XQUICK_END (qc);
+        assert(qc == (quick_widgets + (sizeof(quick_widgets)/sizeof(quick_widgets[0]))));
+#endif  //WIN32, quick
+
+#ifdef ENABLE_VFS_FTP
+        if (!ftpfs_always_use_proxy)
+            quick_widgets[5].options = W_DISABLED;
+#endif
+
+        if (quick_dialog (&qdlg) != B_CANCEL)
+        {
+            /* cppcheck-suppress uninitvar */
+            vfs_timeout = atoi (ret_timeout);
+            g_free (ret_timeout);
+
+            if (vfs_timeout < 0 || vfs_timeout > 10000)
+                vfs_timeout = 10;
+#ifdef ENABLE_VFS_FTP
+            g_free (ftpfs_anonymous_passwd);
+            /* cppcheck-suppress uninitvar */
+            ftpfs_anonymous_passwd = ret_passwd;
+            g_free (ftpfs_proxy_host);
+            /* cppcheck-suppress uninitvar */
+            ftpfs_proxy_host = ret_ftp_proxy;
+            /* cppcheck-suppress uninitvar */
+            ftpfs_directory_timeout = atoi (ret_directory_timeout);
+            g_free (ret_directory_timeout);
+#endif
+        }
+    }
+}
+
+#endif /* ENABLE_VFS */
+
+/* --------------------------------------------------------------------------------------------- */
+
+char *
+cd_dialog (void)
+{
+    const Widget *w = WIDGET (current_panel);
+    char *my_str;
+
+#if defined(WIN32)  //WIN32, quick
+    quick_widget_t quick_widgets[2],
+            *qc = quick_widgets;
+#else
+    quick_widget_t quick_widgets[] = {
+        QUICK_LABELED_INPUT (N_("cd"), input_label_left, "", "input", &my_str, NULL, FALSE, TRUE,
+                             INPUT_COMPLETE_FILENAMES | INPUT_COMPLETE_CD),
+        QUICK_END
+    };
+#endif  //WIN32, quick
+
+    quick_dialog_t qdlg = {
+        w->y + w->lines - 6, w->x, w->cols,
+        N_("Quick cd"), "[Quick cd]",
+        quick_widgets, NULL, NULL
+    };
+
+#if defined(WIN32)  //WIN32, quick
+    qc = XQUICK_LABELED_INPUT (qc, N_("cd"), input_label_left, "", 2, "input", &my_str, NULL);
+    qc = XQUICK_END (qc);
+    assert(qc == (quick_widgets + (sizeof(quick_widgets)/sizeof(quick_widgets[0]))));
+#endif  //WIN32, quick
+
+    return (quick_dialog (&qdlg) != B_CANCEL) ? my_str : NULL;
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+void
+symlink_dialog (const vfs_path_t * existing_vpath, const vfs_path_t * new_vpath,
+                char **ret_existing, char **ret_new)
+{
+    quick_widget_t quick_widgets[] = {
+        /* *INDENT-OFF* */
+        QUICK_LABELED_INPUT (N_("Existing filename (filename symlink will point to):"),
+                             input_label_above, vfs_path_as_str (existing_vpath), "input-2",
+                             ret_existing, NULL, FALSE, FALSE, INPUT_COMPLETE_FILENAMES),
+        QUICK_SEPARATOR (FALSE),
+        QUICK_LABELED_INPUT (N_("Symbolic link filename:"), input_label_above,
+                             vfs_path_as_str (new_vpath), "input-1",
+                             ret_new, NULL, FALSE, FALSE, INPUT_COMPLETE_FILENAMES),
+        QUICK_BUTTONS_OK_CANCEL,
+        QUICK_END
+        /* *INDENT-ON* */
+    };
+
+    quick_dialog_t qdlg = {
+        -1, -1, 64,
+        N_("Symbolic link"), "[File Menu]",
+        quick_widgets, NULL, NULL
+    };
+
+    if (quick_dialog (&qdlg) == B_CANCEL)
+    {
+<<<<<<< HEAD
+#if defined(WIN32)  //WIN32, quick
+        quick_widget_t quick_widgets[5+2],
+                *qc = quick_widgets;
+#else
+        quick_widget_t quick_widgets[] = {
+            /* *INDENT-OFF* */
+            QUICK_LABELED_INPUT (N_("Existing filename (filename symlink will point to):"),
+                                 input_label_above,
+                                 existing, 0, "input-2", ret_existing, NULL),
+            QUICK_SEPARATOR (FALSE),
+            QUICK_LABELED_INPUT (N_("Symbolic link filename:"), input_label_above,
+                                 new, 0, "input-1", ret_new, NULL),
+            QUICK_BUTTONS_OK_CANCEL,
+            QUICK_END
+            /* *INDENT-ON* */
+        };
+#endif  //WIN32, quick
+
+        quick_dialog_t qdlg = {
+            -1, -1, 64,
+            N_("Symbolic link"), "[File Menu]",
+            quick_widgets, NULL, NULL
+        };
+
+#if defined(WIN32)  //WIN32, quick
+        qc = XQUICK_LABELED_INPUT (qc, N_("Existing filename (filename symlink will point to):"),
+                                       input_label_above,
+                                       existing, 0, "input-2", ret_existing, NULL);
+        qc = XQUICK_SEPARATOR (qc, FALSE);
+        qc = XQUICK_LABELED_INPUT (qc, N_("Symbolic link filename:"), input_label_above,
+                                        new, 0, "input-1", ret_new, NULL);
+        qc = XQUICK_BUTTONS_OK_CANCEL (qc);
+        qc = XQUICK_END (qc);
+        assert(qc == (quick_widgets + (sizeof(quick_widgets)/sizeof(quick_widgets[0]))));
+#endif  //WIN32, quick
+
+        if (quick_dialog (&qdlg) == B_CANCEL)
+        {
+            *ret_new = NULL;
+            *ret_existing = NULL;
+        }
+=======
+        *ret_new = NULL;
+        *ret_existing = NULL;
+>>>>>>> 4.8.11
+    }
+}
+
+/* --------------------------------------------------------------------------------------------- */
+
+#ifdef ENABLE_BACKGROUND
+void
+jobs_cmd (void)
+{
+    struct
+    {
+        const char *name;
+        int flags;
+        int value;
+        int len;
+        bcback_fn callback;
+    }
+    job_but[] =
+    {
+        /* *INDENT-OFF* */
+        { N_("&Stop"), NORMAL_BUTTON, B_STOP, 0, task_cb },
+        { N_("&Resume"), NORMAL_BUTTON, B_RESUME, 0, task_cb },
+        { N_("&Kill"), NORMAL_BUTTON, B_KILL, 0, task_cb },
+        { N_("&OK"), DEFPUSH_BUTTON, B_CANCEL, 0, NULL }
+        /* *INDENT-ON* */
+    };
+
+    size_t i;
+    const size_t n_but = G_N_ELEMENTS (job_but);
+
+    WDialog *jobs_dlg;
+    int cols = 60;
+    int lines = 15;
+    int x = 0;
+
+    for (i = 0; i < n_but; i++)
+    {
+#ifdef ENABLE_NLS
+        job_but[i].name = _(job_but[i].name);
+#endif /* ENABLE_NLS */
+
+        job_but[i].len = str_term_width1 (job_but[i].name) + 3;
+        if (job_but[i].flags == DEFPUSH_BUTTON)
+            job_but[i].len += 2;
+        x += job_but[i].len;
+    }
+
+    x += (int) n_but - 1;
+    cols = max (cols, x + 6);
+
+    jobs_dlg = dlg_create (TRUE, 0, 0, lines, cols, dialog_colors, NULL, NULL,
+                           "[Background jobs]", _("Background jobs"), DLG_CENTER);
+
+    bg_list = listbox_new (2, 2, lines - 6, cols - 6, FALSE, NULL);
+    jobs_fill_listbox (bg_list);
+    add_widget (jobs_dlg, bg_list);
+
+    add_widget (jobs_dlg, hline_new (lines - 4, -1, -1));
+
+    x = (cols - x) / 2;
+    for (i = 0; i < n_but; i++)
+    {
+        add_widget (jobs_dlg,
+                    button_new (lines - 3, x, job_but[i].value, job_but[i].flags, job_but[i].name,
+                                job_but[i].callback));
+        x += job_but[i].len + 1;
+    }
+
+    (void) dlg_run (jobs_dlg);
+    dlg_destroy (jobs_dlg);
+}
+#endif /* ENABLE_BACKGROUND */
+
+/* --------------------------------------------------------------------------------------------- */
+
+#ifdef ENABLE_VFS_SMB
+struct smb_authinfo *
+vfs_smb_get_authinfo (const char *host, const char *share, const char *domain, const char *user)
+{
+    char *label;
+    struct smb_authinfo *return_value = NULL;
+
+    if (domain == NULL)
+        domain = "";
+    if (user == NULL)
+        user = "";
+
+    label = g_strdup_printf (_("Password for \\\\%s\\%s"), host, share);
+
+    {
+        char *ret_domain, *ret_user, *ret_password;
+
+        quick_widget_t quick_widgets[] = {
+            /* *INDENT-OFF* */
+            QUICK_LABEL (label, NULL),
+            QUICK_SEPARATOR (TRUE),
+            QUICK_START_COLUMNS,
+                QUICK_LABEL (N_("Domain:"), NULL),
+                QUICK_SEPARATOR (FALSE),
+                QUICK_LABEL (N_("Username:"), NULL),
+                QUICK_SEPARATOR (FALSE),
+                QUICK_LABEL (N_("Password:"), NULL),
+            QUICK_NEXT_COLUMN,
+                QUICK_INPUT (domain, "auth_domain", &ret_domain, NULL, FALSE, FALSE, INPUT_COMPLETE_HOSTNAMES),
+                QUICK_SEPARATOR (FALSE),
+                QUICK_INPUT (user, "auth_name", &ret_user, NULL, FALSE, FALSE, INPUT_COMPLETE_USERNAMES),
+                QUICK_SEPARATOR (FALSE),
+                QUICK_INPUT ("", "auth_password", &ret_password, NULL, TRUE, FALSE, INPUT_COMPLETE_NONE),
+            QUICK_STOP_COLUMNS,
+            QUICK_BUTTONS_OK_CANCEL,
+            QUICK_END
+            /* *INDENT-ON* */
+        };
+
+        quick_dialog_t qdlg = {
+            -1, -1, 40,
+            N_("SMB authentication"), "[Smb Authinfo]",
+            quick_widgets, NULL, NULL
+        };
+
+        if (quick_dialog (&qdlg) != B_CANCEL)
+        {
+            return_value = vfs_smb_authinfo_new (host, share, ret_domain, ret_user, ret_password);
+
+            g_free (ret_domain);
+            g_free (ret_user);
+            g_free (ret_password);
+        }
+    }
+
+    g_free (label);
+
+    return return_value;
+}
+#endif /* ENABLE_VFS_SMB */
+
+/* --------------------------------------------------------------------------------------------- */
diff --git a/src/filemanager/ext.c b/src/filemanager/ext.c
index 5828142..f819511 100644
--- a/src/filemanager/ext.c
+++ b/src/filemanager/ext.c
@@ -38,6 +38,11 @@
 #include <string.h>
 #include <unistd.h>
 
+#if defined(USE_LIBMAGIC) //WIN32/APY,libmagic
+#include <magic.h>
+#elif defined(WIN32)
+#error libmagic not defined ...
+#endif
 #include "lib/global.h"
 #include "lib/tty/tty.h"
 #include "lib/search.h"
@@ -348,6 +353,7 @@ exec_make_shell_string (const char *lc_data, const vfs_path_t * filename_vpath)
     return g_string_free (shell_string, FALSE);
 }
 
+
 /* --------------------------------------------------------------------------------------------- */
 
 static void
@@ -463,6 +469,37 @@ exec_extension (void *target, const vfs_path_t * filename_vpath, const char *lc_
         g_free (export_variables);
     }
 
+#if defined(WIN32) // APY, command
+    { static const char XEXTHELPERSDIR[] = "@EXTHELPERSDIR@";
+      const char *cursor;
+
+      if (NULL != (cursor = strstr(shell_string, XEXTHELPERSDIR))) {
+        /*
+         *  Dynamically replace EXTHELPERSDIR references, allowing for variable 
+         *  installation configuration.
+         *
+         *      <prefix>"<libexedir>/<postfix>" ....
+         */
+        const char *exthelperdir = mc_LIBEXECDIR();
+        const int prefix = cursor - shell_string;
+        char *t_shell_string;
+        int postfix = 0;
+
+        cursor += sizeof(XEXTHELPERSDIR) - 1;
+        if (*cursor == PATH_SEP) ++cursor;
+        while (cursor[postfix] && ' ' != cursor[postfix]) {
+            ++postfix;
+        }
+                                                /* rebuild path specification */
+        t_shell_string = g_strdup_printf ("%.*s\"%s%c%.*s\"%s",
+                prefix, shell_string, exthelperdir, PATH_SEP, postfix, cursor, cursor + postfix);
+
+        g_free (shell_string);
+        shell_string = t_shell_string;
+      }
+    }
+#endif  //WIN32
+
     fputs (shell_string, cmd_file);
     g_free (shell_string);
 
@@ -471,8 +508,10 @@ exec_extension (void *target, const vfs_path_t * filename_vpath, const char *lc_
      * Don't do it for the viewer - it may need to rerun the script,
      * so we clean up after calling view().
      */
+#if !defined(WIN32) // APY, command
     if (!run_view)
         fprintf (cmd_file, "\n/bin/rm -f %s\n", vfs_path_as_str (script_vpath));
+#endif //WIN32
 
     fclose (cmd_file);
 
@@ -508,6 +547,9 @@ exec_extension (void *target, const vfs_path_t * filename_vpath, const char *lc_
                                        LINES - mc_global.keybar_visible -
                                        output_lines - 1, LINES - mc_global.keybar_visible - 1);
         }
+#if defined(WIN32) // APY, command
+        w32_unlink (vfs_path_as_str (script_vpath));
+#endif //WIN32
     }
 
     g_free (cmd);
@@ -571,14 +613,39 @@ get_popen_information (const char *cmd_file, const char *args, char *buf, int bu
 static int
 get_file_type_local (const vfs_path_t * filename_vpath, char *buf, int buflen)
 {
+#if defined(HAVE_LIBMAGIC) //WIN32/APY, libmagic
+    static struct magic_set *ms;                /* oneshot */
+    const char *m;
     char *tmp;
+
+    if (NULL == ms) {
+        if (NULL == (ms = magic_open(MAGIC_NONE)) ||
+                magic_load(ms, mc_MAGICPATH()) == -1) {
+            message (1, MSG_ERROR,
+                _(" Cannot load magic db \"%s\"\n %s "),
+                mc_MAGICPATH(), (ms ? magic_error(ms) : _("cannot initialise")) );
+        }
+    }
+    buf[0] = 0;
+    tmp = name_quote (vfs_path_get_last_path_str (filename_vpath), 0);
+    if (ms != NULL && (m = magic_file(ms, tmp)) != NULL) {
+        strncat(buf, m, buflen);
+    } else {
+        strncat(buf, "unknown", buflen);
+    }
+    g_free (tmp);
+    return 1;
+
+#else
     int ret;
+    char *tmp;
 
     tmp = name_quote (vfs_path_get_last_path_str (filename_vpath), 0);
     ret = get_popen_information (FILE_CMD, tmp, buf, buflen);
     g_free (tmp);
 
     return ret;
+#endif
 }
 
 /* --------------------------------------------------------------------------------------------- */
@@ -933,7 +1000,11 @@ regex_command_for (void *target, const vfs_path_t * filename_vpath, const char *
             }
             else if (strncmp (p, "shell/", 6) == 0)
             {
+#if defined(__WATCOMC__) //APY, calling
+                int (__watcall * cmp_func) (const char *s1, const char *s2, size_t n) = strncmp;
+#else
                 int (*cmp_func) (const char *s1, const char *s2, size_t n) = strncmp;
+#endif
 
                 p += 6;
                 case_insense = (strncmp (p, "i/", 2) == 0);
diff --git a/src/filemanager/file.c b/src/filemanager/file.c
index e1bf195..076a4fb 100644
--- a/src/filemanager/file.c
+++ b/src/filemanager/file.c
@@ -610,7 +610,7 @@ static FileProgressStatus
 progress_update_one (file_op_total_context_t * tctx, file_op_context_t * ctx, off_t add)
 {
     struct timeval tv_current;
-    static struct timeval tv_start = { };
+    static struct timeval tv_start = {0};   //WIN32, fix
 
     tctx->progress_count++;
     tctx->progress_bytes += (uintmax_t) add;
diff --git a/src/filemanager/filegui.c b/src/filemanager/filegui.c
index dfc88ca..cf799e4 100644
--- a/src/filemanager/filegui.c
+++ b/src/filemanager/filegui.c
@@ -1223,6 +1223,14 @@ file_mask_dialog (file_op_context_t * ctx, FileOperation operation,
         int val;
         struct stat buf;
 
+#if defined(WIN32)  //WIN32, quick
+#ifdef ENABLE_BACKGROUND
+        quick_widget_t quick_widgets[20],
+#else
+        quick_widget_t quick_widgets[19],
+#endif
+            *qc = quick_widgets;
+#else
         quick_widget_t quick_widgets[] = {
             /* *INDENT-OFF* */
             QUICK_LABELED_INPUT (fmd_buf, input_label_above,
@@ -1252,6 +1260,7 @@ file_mask_dialog (file_op_context_t * ctx, FileOperation operation,
             QUICK_END
             /* *INDENT-ON* */
         };
+#endif  //WIN32
 
         quick_dialog_t qdlg = {
             -1, -1, fmd_xlen,
@@ -1259,6 +1268,35 @@ file_mask_dialog (file_op_context_t * ctx, FileOperation operation,
             quick_widgets, NULL, NULL
         };
 
+#if defined(WIN32)  //WIN32, quick
+        qc = XQUICK_LABELED_INPUT (qc, fmd_buf, input_label_above,
+                                       easy_patterns ? "*" : "^(.*)$", "input-def", &source_mask,
+                                       NULL, FALSE, FALSE, INPUT_COMPLETE_FILENAMES);
+        qc = XQUICK_START_COLUMNS (qc);
+        qc =      XQUICK_SEPARATOR (qc, FALSE);
+        qc = XQUICK_NEXT_COLUMN (qc);
+        qc =      XQUICK_CHECKBOX (qc, N_("&Using shell patterns"), &source_easy_patterns, NULL);
+        qc = XQUICK_STOP_COLUMNS (qc);
+        qc = XQUICK_LABELED_INPUT (qc, N_("to:"), input_label_above,
+                                       def_text_secure, "input2", &dest_dir, NULL, FALSE, FALSE, INPUT_COMPLETE_FILENAMES);
+        qc = XQUICK_SEPARATOR (qc, TRUE);
+        qc = XQUICK_START_COLUMNS (qc);
+        qc =      XQUICK_CHECKBOX (qc, N_("Follow &links"), &ctx->follow_links, NULL);
+        qc =      XQUICK_CHECKBOX (qc, N_("Preserve &attributes"), &ctx->op_preserve, NULL);
+        qc = XQUICK_NEXT_COLUMN (qc);
+        qc =      XQUICK_CHECKBOX (qc, N_("Di&ve into subdir if exists"), &ctx->dive_into_subdirs, NULL);
+        qc =      XQUICK_CHECKBOX (qc, N_("&Stable symlinks"), &ctx->stable_symlinks, NULL);
+        qc = XQUICK_STOP_COLUMNS (qc);
+        qc = XQUICK_START_BUTTONS (qc, TRUE, TRUE);
+        qc =      XQUICK_BUTTON (qc, N_("&OK"), B_ENTER, NULL, NULL);
+#ifdef ENABLE_BACKGROUND
+        qc =      XQUICK_BUTTON (qc, N_("&Background"), B_USER, NULL, NULL);
+#endif /* ENABLE_XBACKGROUND */
+        qc =      XQUICK_BUTTON (qc, N_("&Cancel"), B_CANCEL, NULL, NULL);
+        qc = XQUICK_END (qc);
+        assert(qc == (quick_widgets + (sizeof(quick_widgets)/sizeof(quick_widgets[0]))));
+#endif
+
       ask_file_mask:
         val = quick_dialog_skip (&qdlg, 4);
 
diff --git a/src/filemanager/hotlist.c b/src/filemanager/hotlist.c
index 5d2e24d..7d1b299 100644
--- a/src/filemanager/hotlist.c
+++ b/src/filemanager/hotlist.c
@@ -964,6 +964,10 @@ static int
 add_new_entry_input (const char *header, const char *text1, const char *text2,
                      const char *help, char **r1, char **r2)
 {
+#if defined(WIN32)  //WIN32, quick
+    quick_widget_t quick_widgets[8],
+        *qc = quick_widgets;
+#else
     quick_widget_t quick_widgets[] = {
         /* *INDENT-OFF* */
         QUICK_LABELED_INPUT (text1, input_label_above, *r1, "input-lbl", r1, NULL,
@@ -978,6 +982,7 @@ add_new_entry_input (const char *header, const char *text1, const char *text2,
         QUICK_END
         /* *INDENT-ON* */
     };
+#endif  //WIN32
 
     quick_dialog_t qdlg = {
         -1, -1, 64,
@@ -987,6 +992,22 @@ add_new_entry_input (const char *header, const char *text1, const char *text2,
 
     int ret;
 
+#if defined(WIN32)  //WIN32, quick
+    qc = XQUICK_LABELED_INPUT (qc,
+                                text1, input_label_above, *r1, "input-lbl", r1, NULL,
+                                FALSE, FALSE, INPUT_COMPLETE_NONE);
+    qc = XQUICK_SEPARATOR (qc, FALSE);
+    qc = XQUICK_LABELED_INPUT (qc,
+                                text2, input_label_above, *r2, "input-lbl", r2, NULL,
+                                FALSE, FALSE, INPUT_COMPLETE_FILENAMES | INPUT_COMPLETE_CD);
+    qc = XQUICK_START_BUTTONS (qc, TRUE, TRUE);
+    qc =      XQUICK_BUTTON (qc, N_("&Append"), B_APPEND, NULL, NULL);
+    qc =      XQUICK_BUTTON (qc, N_("&Insert"), B_INSERT, NULL, NULL);
+    qc =      XQUICK_BUTTON (qc, N_("&Cancel"), B_CANCEL, NULL, NULL);
+    qc = XQUICK_END (qc); 
+    assert(qc == (quick_widgets + (sizeof(quick_widgets)/sizeof(quick_widgets[0]))));
+#endif
+
     ret = quick_dialog (&qdlg);
 
     return (ret != B_CANCEL) ? ret : 0;
@@ -1029,6 +1050,10 @@ add_new_entry_cmd (void)
 static int
 add_new_group_input (const char *header, const char *label, char **result)
 {
+#if defined(WIN32)  //WIN32, quick
+    quick_widget_t quick_widgets[6],
+        *qc = quick_widgets;
+#else
     quick_widget_t quick_widgets[] = {
         /* *INDENT-OFF* */
         QUICK_LABELED_INPUT (label, input_label_above, "", "input", result, NULL,
@@ -1040,6 +1065,7 @@ add_new_group_input (const char *header, const char *label, char **result)
         QUICK_END
         /* *INDENT-ON* */
     };
+#endif  //WIN32
 
     quick_dialog_t qdlg = {
         -1, -1, 64,
@@ -1049,6 +1075,18 @@ add_new_group_input (const char *header, const char *label, char **result)
 
     int ret;
 
+#if defined(WIN32)  //WIN32, quick
+    qc = XQUICK_LABELED_INPUT (qc,
+                                label, input_label_above, "", "input", result, NULL,
+                                FALSE, FALSE, INPUT_COMPLETE_NONE);
+    qc = XQUICK_START_BUTTONS (qc, TRUE, TRUE);
+    qc =      XQUICK_BUTTON (qc, N_("&Append"), B_APPEND, NULL, NULL);
+    qc =      XQUICK_BUTTON (qc, N_("&Insert"), B_INSERT, NULL, NULL);
+    qc =      XQUICK_BUTTON (qc, N_("&Cancel"), B_CANCEL, NULL, NULL);
+    qc = XQUICK_END (qc);
+    assert(qc == (quick_widgets + (sizeof(quick_widgets)/sizeof(quick_widgets[0]))));
+#endif
+
     ret = quick_dialog (&qdlg);
 
     return (ret != B_CANCEL) ? ret : 0;
diff --git a/src/filemanager/listmode.c b/src/filemanager/listmode.c
index 4a3080b..46f7cfa 100644
--- a/src/filemanager/listmode.c
+++ b/src/filemanager/listmode.c
@@ -44,7 +44,7 @@
 
 #include "lib/tty/tty.h"
 #include "lib/tty/key.h"
-#include "lib/skin/skin.h"
+//missing,  #include "lib/skin/skin.h"
 
 /* Needed for the extern declarations of integer parameters */
 #include "dir.h"
@@ -74,7 +74,10 @@ struct listmode_button
 {
     int ret_cmd, flags, y, x;
     char *text;
-    bcback callback;
+//WIN32, fix
+//  bcback callback;    
+    bcback_fn callback;
+
 };
 
 struct listmode_label
@@ -89,18 +92,18 @@ static WListbox *l_listmode;
 
 static WLabel *pname;
 
-static char *listmode_section = "[Listing format edit]";
+static const char *listmode_section = "[Listing format edit]";
 
-static char *s_genwidth[2] = { "Half width", "Full width" };
+static const char *s_genwidth[2] = { "Half width", "Full width" };
 
 static WRadio *radio_genwidth;
-static char *s_columns[2] = { "One column", "Two columns" };
+static const char *s_columns[2] = { "One column", "Two columns" };
 
 static WRadio *radio_columns;
-static char *s_justify[3] = { "Left justified", "Default justification", "Right justified" };
+static const char *s_justify[3] = { "Left justified", "Default justification", "Right justified" };
 
 static WRadio *radio_justify;
-static char *s_itemwidth[3] = { "Free width", "Fixed width", "Growable width" };
+static const char *s_itemwidth[3] = { "Free width", "Fixed width", "Growable width" };
 
 static WRadio *radio_itemwidth;
 
@@ -110,7 +113,7 @@ static WRadio *radio_itemwidth;
 static char *
 select_new_item (void)
 {
-    char **possible_items;
+    const char **possible_items;    //APY,fix
     char *ret = NULL;
     int i;
     Listbox *mylistbox;
@@ -127,14 +130,14 @@ select_new_item (void)
     if (i >= 0)
         ret = g_strdup (possible_items[i]);
 
-    g_strfreev (possible_items);
+    g_strfreev ((char **)possible_items);
     return ret;
 }
 
 /* --------------------------------------------------------------------------------------------- */
 
 static int
-bplus_cback (int action)
+bplus_cback (struct WButton *b, int action)
 {
     return 0;
 }
@@ -142,7 +145,7 @@ bplus_cback (int action)
 /* --------------------------------------------------------------------------------------------- */
 
 static int
-bminus_cback (int action)
+bminus_cback (struct WButton *b, int action)
 {
     return 0;
 }
@@ -150,7 +153,7 @@ bminus_cback (int action)
 /* --------------------------------------------------------------------------------------------- */
 
 static int
-badd_cback (int action)
+badd_cback (struct WButton *b, int action)
 {
     char *s = select_new_item ();
     if (s)
@@ -164,7 +167,7 @@ badd_cback (int action)
 /* --------------------------------------------------------------------------------------------- */
 
 static int
-bremove_cback (int action)
+bremove_cback (struct WButton *b, int action)
 {
     listbox_remove_current (l_listmode);
     return 0;
@@ -196,6 +199,9 @@ init_listmode (char *oldlistformat)
 
     do_refresh ();
 
+#ifndef DLG_REVERSE
+#define DLG_REVERSE 0   //WIN32,missing
+#endif
     listmode_dlg =
         dlg_create (TRUE, 0, 0, 22, 74, dialog_colors, NULL, NULL, listmode_section,
                     "Listing format edit", DLG_CENTER | DLG_REVERSE);
@@ -286,7 +292,8 @@ collect_new_format (void)
     char *newformat;
     int i;
     char *last;
-    char *text, *extra;
+    char *text;
+    void *extra;
 
     newformat = g_malloc (1024);
     if (radio_genwidth->sel)
diff --git a/src/filemanager/midnight.c b/src/filemanager/midnight.c
index da25d75..8875d6e 100644
--- a/src/filemanager/midnight.c
+++ b/src/filemanager/midnight.c
@@ -63,6 +63,9 @@
 #include "src/keybind-defaults.h"
 #include "lib/keybind.h"
 #include "lib/event.h"
+#ifdef LISTMODE_EDITOR
+#include "listmode.h"           /* missing */
+#endif
 
 #include "tree.h"
 #include "boxes.h"              /* sort_box(), tree_box() */
@@ -1019,7 +1022,7 @@ mc_maybe_editor_or_viewer (void)
 
 /* --------------------------------------------------------------------------------------------- */
 
-static gboolean
+/*static, WIN32*/ gboolean
 quit_cmd_internal (int quiet)
 {
     int q = quit;
@@ -1100,6 +1103,12 @@ toggle_show_hidden (void)
 
 /* --------------------------------------------------------------------------------------------- */
 
+#if defined(WIN32)
+extern void drive_cmd_a(void);
+extern void drive_cmd_b(void);
+extern void drive_cmd(void);
+#endif
+
 static cb_ret_t
 midnight_execute_cmd (Widget * sender, unsigned long command)
 {
@@ -1389,6 +1398,17 @@ midnight_execute_cmd (Widget * sender, unsigned long command)
     case CK_Cancel:
         /* don't close panels due to SIGINT */
         break;
+#if defined(WIN32) //APY, drive
+    case CK_DriveChangeA:
+        drive_cmd_a();
+        break;
+    case CK_DriveChangeB:
+        drive_cmd_b();
+        break;
+    case CK_DriveChange:
+        drive_cmd();
+        break;
+#endif
     default:
         res = MSG_NOT_HANDLED;
     }
diff --git a/src/filemanager/panel.c b/src/filemanager/panel.c
index 4c36d1e..1050f20 100644
--- a/src/filemanager/panel.c
+++ b/src/filemanager/panel.c
@@ -1539,7 +1539,7 @@ panel_get_title_without_hotkey (const char *title)
 
         hkey = strchr (translated_title, '&');
         if (hkey != NULL && hkey[1] != '\0')
-            memmove ((void *) hkey, (void *) hkey + 1, strlen (hkey));
+            memmove ((void *) hkey, (void *)(hkey + 1), strlen (hkey));
     }
 
     return translated_title;
@@ -2424,6 +2424,10 @@ panel_select_unselect_files (WPanel * panel, const char *title, const char *hist
     mc_search_t *search;
     int i;
 
+#if defined(WIN32)  //WIN32, quick
+    quick_widget_t quick_widgets[8+2],
+        *qc = quick_widgets;
+#else
     quick_widget_t quick_widgets[] = {
         /* *INDENT-OFF* */
         QUICK_INPUT (INPUT_LAST_TEXT, history_name, &reg_exp, NULL,
@@ -2437,6 +2441,20 @@ panel_select_unselect_files (WPanel * panel, const char *title, const char *hist
         QUICK_END
         /* *INDENT-ON* */
     };
+#endif
+
+#if defined(WIN32)  //WIN32, quick
+    qc = XQUICK_INPUT (qc, INPUT_LAST_TEXT, history_name, &reg_exp, NULL,
+                    FALSE, FALSE, INPUT_COMPLETE_FILENAMES);
+    qc = XQUICK_START_COLUMNS (qc);
+    qc =    XQUICK_CHECKBOX (qc, N_("&Files only"), &files_only, NULL);
+    qc =    XQUICK_CHECKBOX (qc, N_("&Using shell patterns"), &shell_patterns, NULL);
+    qc = XQUICK_NEXT_COLUMN (qc);
+    qc =    XQUICK_CHECKBOX (qc, N_("&Case sensitive"), &case_sens, NULL);
+    qc = XQUICK_STOP_COLUMNS (qc);
+    qc = XQUICK_END (qc);
+    assert(qc == (quick_widgets + (sizeof(quick_widgets)/sizeof(quick_widgets[0]))));
+#endif
 
     quick_dialog_t qdlg = {
         -1, -1, 50,
diff --git a/src/keybind-defaults.c b/src/keybind-defaults.c
index 7615cab..9c12476 100644
--- a/src/keybind-defaults.c
+++ b/src/keybind-defaults.c
@@ -130,6 +130,12 @@ static const global_keymap_ini_t default_main_keymap[] = {
     {"SelectInvert", "kpasterisk"},
     /* List of screens */
     {"ScreenList", "alt-prime"},
+#if defined(WIN32) //APY, drive
+    /* Change drive */
+    {"DriveChange", "alt-d"},
+    {"DriveChangeA", "alt-f1"},
+    {"DriveChangeB", "alt-f2"},
+#endif
     {NULL, NULL}
 };
 
diff --git a/src/main.c b/src/main.c
index 377f0dc..cce93f4 100644
--- a/src/main.c
+++ b/src/main.c
@@ -1,8 +1,9 @@
 /*
    Main program for the Midnight Commander
 
-   Copyright (C) 1994-2014
-   Free Software Foundation, Inc.
+   Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+   2003, 2004, 2005, 2006, 2007, 2009, 2011
+   The Free Software Foundation, Inc.
 
    Written by:
    Miguel de Icaza, 1994, 1995, 1996, 1997
@@ -151,7 +152,14 @@ OS_Setup (void)
     else
         mc_global.sysconfig_dir = g_strdup (SYSCONFDIR);
 
+#if defined(MC_DATADIR) //WIN32,namespace
+    mc_global.share_data_dir = g_strdup (MC_DATADIR);
+#else
     mc_global.share_data_dir = g_strdup (DATADIR);
+#endif
+
+    /* Set up temporary directory */
+//  mc_tmpdir ();
 }
 
 /* --------------------------------------------------------------------------------------------- */
@@ -162,7 +170,7 @@ sigchld_handler_no_subshell (int sig)
 #ifdef __linux__
     int pid, status;
 
-    if (mc_global.tty.console_flag == '\0')
+    if (!mc_global.tty.console_flag != '\0')
         return;
 
     /* COMMENT: if it were true that after the call to handle_console(..INIT)
@@ -176,6 +184,7 @@ sigchld_handler_no_subshell (int sig)
 
     if (pid == cons_saver_pid)
     {
+
         if (WIFSTOPPED (status))
         {
             /* Someone has stopped cons.saver - restart it */
@@ -233,6 +242,9 @@ init_sigchld (void)
 int
 main (int argc, char *argv[])
 {
+#if defined(WIN32) //APY, config
+    extern void WIN32_Setup(void);
+#endif //WIN32
     GError *mcerror = NULL;
     gboolean config_migrated = FALSE;
     char *config_migrate_msg;
@@ -245,6 +257,9 @@ main (int argc, char *argv[])
     (void) bindtextdomain (PACKAGE, LOCALEDIR);
     (void) textdomain (PACKAGE);
 
+#if defined(WIN32) //APY, config
+    WIN32_Setup();
+#endif
     /* do this before args parsing */
     str_init_strings (NULL);
 
@@ -264,8 +279,8 @@ main (int argc, char *argv[])
 
     if (!g_path_is_absolute (mc_config_get_home_dir ()))
     {
-        mc_propagate_error (&mcerror, 0, "%s: %s", _("Home directory path is not absolute"),
-                            mc_config_get_home_dir ());
+        mcerror = g_error_new (MC_ERROR, 0, "%s: %s", _("Home directory path is not absolute"),
+                             mc_config_get_home_dir ());
         mc_event_deinit (NULL);
         goto startup_exit_falure;
     }
@@ -280,7 +295,8 @@ main (int argc, char *argv[])
         goto startup_exit_falure;
 
     mc_config_init_config_paths (&mcerror);
-    config_migrated = mc_config_migrate_from_old_place (&mcerror, &config_migrate_msg);
+    if (mcerror == NULL)
+        config_migrated = mc_config_migrate_from_old_place (&mcerror, &config_migrate_msg);
     if (mcerror != NULL)
     {
         mc_event_deinit (NULL);
@@ -289,36 +305,15 @@ main (int argc, char *argv[])
 
     vfs_init ();
     vfs_plugins_init ();
-
-    load_setup ();
-
-    /* Must be done after load_setup because depends on mc_global.vfs.cd_symlinks */
     vfs_setup_work_dir ();
 
-    /* Resolve the other_dir panel option. Must be done after vfs_setup_work_dir */
-    {
-        char *buffer;
-        vfs_path_t *vpath;
-
-        buffer = mc_config_get_string (mc_panels_config, "Dirs", "other_dir", ".");
-        vpath = vfs_path_from_str (buffer);
-        if (vfs_file_is_local (vpath))
-            saved_other_dir = buffer;
-        else
-            g_free (buffer);
-        vfs_path_free (vpath);
-    }
-
     /* Set up temporary directory after VFS initialization */
     mc_tmpdir ();
 
-    /* do this after vfs initialization and vfs working directory setup
-       due to mc_setctl() and mcedit_arg_vpath_new() calls in mc_setup_by_args() */
+    /* do this after vfs initialization due to mc_setctl() call in mc_setup_by_args() */
     if (!mc_setup_by_args (argc, argv, &mcerror))
     {
         vfs_shut ();
-        done_setup ();
-        g_free (saved_other_dir);
         mc_event_deinit (NULL);
         goto startup_exit_falure;
     }
@@ -356,6 +351,8 @@ main (int argc, char *argv[])
     /* FIXME: Should be removed and LINES and COLS computed on subshell */
     tty_init (!mc_args__nomouse, mc_global.tty.xterm_flag);
 
+    load_setup ();
+
     /* start check mc_global.display_codepage and mc_global.source_codepage */
     check_codeset ();
 
@@ -369,12 +366,14 @@ main (int argc, char *argv[])
     tty_init_colors (mc_global.tty.disable_colors, mc_args__force_colors);
 
     mc_skin_init (NULL, &mcerror);
-    dlg_set_default_colors ();
-    input_set_default_colors ();
-    if (mc_global.mc_run_mode == MC_RUN_FULL)
-        command_set_default_colors ();
+    if (mcerror != NULL)
+    {
+        message (D_ERROR, _("Warning"), "%s", mcerror->message);
+        g_error_free (mcerror);
+        mcerror = NULL;
+    }
 
-    mc_error_message (&mcerror);
+    dlg_set_default_colors ();
 
 #ifdef ENABLE_SUBSHELL
     /* Done here to ensure that the subshell doesn't  */
diff --git a/src/textconf.c b/src/textconf.c
index 0414000..3a3d04a 100644
--- a/src/textconf.c
+++ b/src/textconf.c
@@ -199,6 +199,10 @@ show_datadirs_extended (void)
     PRINTF2 ("fish:", LIBEXECDIR, FISH_PREFIX "/");
 #endif
 #endif /* ENABLE_VFS_EXTFS || defiined ENABLE_VFS_FISH */
+#if defined(HAVE_LIBMAGIC) //WIN32/APY, libmagic
+    PRINTF2 ("magic:", mc_MAGICPATH(), "");
+#endif
+
     (void) puts ("");
 
     PRINTF_GROUP (_("User data"));
@@ -215,6 +219,27 @@ show_datadirs_extended (void)
 #ifdef USE_INTERNAL_EDIT
     PRINTF ("mcedit macros:", mc_config_get_data_path (), MC_MACRO_FILE);
     PRINTF ("mcedit external macros:", mc_config_get_data_path (), MC_EXTMACRO_FILE ".*");
+#if defined(WIN32) //APY, conf
+    {
+        static const struct {
+            const char *desc, *key;
+        } editpaths[] = {
+            { "syntax:",      EDIT_SYNTAX_FILE  },
+            { "clip:",        EDIT_CLIP_FILE    },
+            { "block:",       EDIT_BLOCK_FILE   },
+            { "temp:",        EDIT_TEMP_FILE    },
+            { "global-menu:", EDIT_GLOBAL_MENU  },
+            { "local-menu:",  EDIT_LOCAL_MENU   },
+            { "home-menu:",   EDIT_HOME_MENU    }
+            };
+
+        for (int i = 0; i < (sizeof(editpaths)/sizeof(editpaths[i])); ++i) {
+            char *f = mc_config_get_full_path (editpaths[i].key);
+            printf ("\tmcedit %-8s %s\n", editpaths[i].desc, (f ? f : "n/a"));
+            g_free (f);
+        }
+    }
+#endif  //WIN32
 #endif
     PRINTF_SECTION2 (_("Cache directory:"), mc_config_get_cache_path ());
 
diff --git a/src/viewer/dialogs.c b/src/viewer/dialogs.c
index 9a18114..56ba6dd 100644
--- a/src/viewer/dialogs.c
+++ b/src/viewer/dialogs.c
@@ -84,6 +84,14 @@ mcview_dialog_search (mcview_t * view)
     list_of_types = mc_search_get_types_strings_array (&num_of_types);
 
     {
+#if defined(WIN32)  //WIN32, quick
+#ifdef HAVE_CHARSET
+        quick_widget_t quick_widgets[12+2],
+#else
+        quick_widget_t quick_widgets[11+2],
+#endif
+            *qc = quick_widgets;
+#else
         quick_widget_t quick_widgets[] = {
             /* *INDENT-OFF* */
             QUICK_LABELED_INPUT (N_("Enter search string:"), input_label_above,
@@ -105,6 +113,7 @@ mcview_dialog_search (mcview_t * view)
             QUICK_END
             /* *INDENT-ON* */
         };
+#endif  //WIN32
 
         quick_dialog_t qdlg = {
             -1, -1, 58,
@@ -112,6 +121,28 @@ mcview_dialog_search (mcview_t * view)
             quick_widgets, NULL, NULL
         };
 
+#if defined(WIN32)  //WIN32, quick
+        qc = XQUICK_LABELED_INPUT (qc,
+                                   N_("Enter search string:"), input_label_above,
+                                   INPUT_LAST_TEXT, MC_HISTORY_SHARED_SEARCH, &exp,
+                                   NULL, FALSE, FALSE, INPUT_COMPLETE_NONE);
+        qc = XQUICK_SEPARATOR (qc, TRUE);
+        qc = XQUICK_START_COLUMNS (qc);
+        qc =    XQUICK_RADIO (qc, num_of_types, (const char **) list_of_types,
+                                (int *) &mcview_search_options.type, NULL);
+        qc = XQUICK_NEXT_COLUMN (qc);
+        qc =    XQUICK_CHECKBOX (qc, N_("Cas&e sensitive"), &mcview_search_options.case_sens, NULL);
+        qc =    XQUICK_CHECKBOX (qc, N_("&Backwards"), &mcview_search_options.backwards, NULL);
+        qc =    XQUICK_CHECKBOX (qc, N_("&Whole words"), &mcview_search_options.whole_words, NULL);
+#ifdef HAVE_CHARSET
+        qc =    XQUICK_CHECKBOX (qc, N_("&All charsets"), &mcview_search_options.all_codepages, NULL);
+#endif
+        qc = XQUICK_STOP_COLUMNS (qc);
+        qc = XQUICK_BUTTONS_OK_CANCEL (qc);
+        qc = XQUICK_END (qc);
+        assert(qc == (quick_widgets + (sizeof(quick_widgets)/sizeof(quick_widgets[0]))));
+#endif  //WIN32
+
         qd_result = quick_dialog (&qdlg);
     }
 
@@ -201,6 +232,10 @@ mcview_dialog_goto (mcview_t * view, off_t * offset)
 #endif
 
     {
+#if defined(WIN32)  //WIN32, quick
+        quick_widget_t quick_widgets[4+2],
+            *qc = quick_widgets;
+#else
         quick_widget_t quick_widgets[] = {
             /* *INDENT-OFF* */
             QUICK_INPUT (INPUT_LAST_TEXT, MC_HISTORY_VIEW_GOTO, &exp, NULL,
@@ -211,6 +246,7 @@ mcview_dialog_goto (mcview_t * view, off_t * offset)
             QUICK_END
             /* *INDENT-ON* */
         };
+#endif  //WIN32
 
         quick_dialog_t qdlg = {
             -1, -1, 40,
@@ -218,6 +254,16 @@ mcview_dialog_goto (mcview_t * view, off_t * offset)
             quick_widgets, NULL, NULL
         };
 
+#if defined(WIN32)  //WIN32, quick
+        qc = XQUICK_INPUT (qc,
+                            INPUT_LAST_TEXT, MC_HISTORY_VIEW_GOTO, &exp, NULL,
+                            FALSE, FALSE, INPUT_COMPLETE_NONE);
+        qc = XQUICK_RADIO (qc, num_of_types, (const char **) mc_view_goto_str, (int *) &current_goto_type, NULL);
+        qc = XQUICK_BUTTONS_OK_CANCEL (qc);
+        qc = XQUICK_END (qc);
+        assert(qc == (quick_widgets + (sizeof(quick_widgets)/sizeof(quick_widgets[0]))));
+#endif  //WIN32
+
         /* run dialog */
         qd_result = quick_dialog (&qdlg);
     }
diff --git a/src/viewer/growbuf.c b/src/viewer/growbuf.c
index 81d2f71..b0d470c 100644
--- a/src/viewer/growbuf.c
+++ b/src/viewer/growbuf.c
@@ -137,7 +137,7 @@ mcview_growbuf_read_until (mcview_t * view, off_t ofs)
             g_ptr_array_add (view->growbuf_blockptr, newblock);
             view->growbuf_lastindex = 0;
         }
-        p = g_ptr_array_index (view->growbuf_blockptr,
+        p = (byte *)g_ptr_array_index (view->growbuf_blockptr,
                                view->growbuf_blockptr->len - 1) + view->growbuf_lastindex;
 
         bytesfree = VIEW_PAGE_SIZE - view->growbuf_lastindex;
@@ -205,14 +205,14 @@ mcview_get_byte_growing_buffer (mcview_t * view, off_t byte_index, int *retval)
     if (pageno < (off_t) view->growbuf_blockptr->len - 1)
     {
         if (retval != NULL)
-            *retval = *((byte *) (g_ptr_array_index (view->growbuf_blockptr, pageno) + pageindex));
+            *retval = *((byte *) ((byte *)g_ptr_array_index (view->growbuf_blockptr, pageno) + pageindex));
         return TRUE;
     }
     if (pageno == (off_t) view->growbuf_blockptr->len - 1
         && pageindex < (off_t) view->growbuf_lastindex)
     {
         if (retval != NULL)
-            *retval = *((byte *) (g_ptr_array_index (view->growbuf_blockptr, pageno) + pageindex));
+            *retval = *((byte *) ((byte *)g_ptr_array_index (view->growbuf_blockptr, pageno) + pageindex));
         return TRUE;
     }
     return FALSE;
@@ -237,10 +237,10 @@ mcview_get_ptr_growing_buffer (mcview_t * view, off_t byte_index)
     if (view->growbuf_blockptr->len == 0)
         return NULL;
     if (pageno < (off_t) view->growbuf_blockptr->len - 1)
-        return (char *) (g_ptr_array_index (view->growbuf_blockptr, pageno) + pageindex);
+        return (char *) ((byte *)g_ptr_array_index (view->growbuf_blockptr, pageno) + pageindex);
     if (pageno == (off_t) view->growbuf_blockptr->len - 1
         && pageindex < (off_t) view->growbuf_lastindex)
-        return (char *) (g_ptr_array_index (view->growbuf_blockptr, pageno) + pageindex);
+        return (char *) ((byte *)g_ptr_array_index (view->growbuf_blockptr, pageno) + pageindex);
     return NULL;
 }
 
